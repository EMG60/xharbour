%{
/****************************************************************************
 *                                                                          *
 * File    : x86.md                                                         *
 *                                                                          *
 * Purpose : Intel 80x86 machine description for Win32.                     *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *           00-10-17  Support for CRT function _alloca() added.            *
 *           03-08-01  Support for #pragma startup and #pragma exit added.  *
 *           03-09-18  Changed interface flag mulops_calls into function.   *
 *           03-09-23  Use __ftoll() is Microsoft mode.                     *
 *           04-03-??  Many changes to generate better code.                *
 *           04-06-23  Bugfix: CEQI8 & friends must(?) return long long.    *
 *           04-07-09  Support for long long integers rewritten.            *
 *           04-11-26  Moved peephole patterns here.                        *
 *           04-12-18  Added fast integer division + many small changes.    *
 *                                                                          *
 ****************************************************************************/

#include "proj.h"
#pragma hdrstop

#include <math.h>
#include <codeview.h>
#include "lcc.h"

/* P6: cmov, fcmov, fcomi */

#define I(f) x86_##f

// ?? LCC 4.2 has different code from LCC 4.1 FCOMP (unordered values?)

enum { EDI=0, ESI=1, EBX=2, ECX=3, EDX=4, EAX=5 };

enum { RT_FTOL = 0, RT_FTOLL, RT_UNWIND, RT_CHKSTK, RT_LLSHL, RT_LLSHR,
       RT_ULLSHR, RT_LLMUL, RT_LLDIV, RT_ULLDIV, RT_LLMOD, RT_ULLMOD,
       RT_MAXCOUNT };

/* sizeof(ebp) + sizeof(retaddr) */
#define ARGOFFSET  (4+4)

/* number of fastcall arguments */
#define NFASTARGS  2

#define NODEPTR_TYPE NODE*
#define OP_LABEL(p) ((p)->op)
#define LEFT_CHILD(p) ((p)->kids[0])
#define RIGHT_CHILD(p) ((p)->kids[1])
#define STATE_LABEL(p) ((p)->x.state)

/* private segment IDs */
#define FPORECS  98
#define CVSYMS  97
#define CVTYPS  96
#define INITFN  95
#define EXITFN  94

static void fatal(const char *fcn, const char *fmt, int arg)
{
    char buf1[100];
    char buf2[200];

    sprintf(buf1, fmt, arg);
    sprintf(buf2, "function %s: %s", fcn, buf1);
    apperror(RCFATAL(ERROR_INTERNAL), buf2);
}

/* Static function prototypes */
static int memop(NODE *);
static int memop2(NODE *);
static int memop3(NODE *);
static int sametree(NODE *, NODE *);
static int popargs(NODE *);
static SYMBOL *regmap(int);
static void target(NODE *);
static void clobber(NODE *);
static int fpstack(NODE *, int);
static void doarg(NODE *);
static void emit2(NODE *);
static int msb(unsigned int);
static int clobber_register(NODE *);
static void blkfetch(int, int, int, int);
static void blkstore(int, int, int, int);
static void blkloop(int, int, int, int, int, int[]);
static void I(progbeg)(void);
static void I(progend)(void);
static void finalize_initexit(SYMBOL *, void *);
static void I(function)(SYMBOL *, SYMBOL *[], SYMBOL *[], int);
static void no_register_floats(void);
static void safe_vmask(uint_t *, bool_t);
static void safe_vmask_tree(uint_t *, bool_t, NODE *);
static void reassign_register(int, int);
static void reassign_register_tree(NODE *, int, int);
static void function_seh(SYMBOL *);
static void I(defsymbol)(SYMBOL *);
static void I(address)(SYMBOL *, SYMBOL *, long);
static void I(defaddress)(SYMBOL *);
static void I(defconst)(int, int, VALUE);
static void I(defstring)(int, char *);
static void I(export)(SYMBOL *);
static void I(import)(SYMBOL *);
static void I(global)(SYMBOL *);
static void I(local)(SYMBOL *);
static void I(segment)(int);
static void I(space)(int);
static void I(sehbeg)(int, SEH *);
static void I(sehend)(int, SEH *);
static void I(unwind)(SEH *);
static int I(opcall)(int);
static void align(int);
static SYMBOL *argreg(int, int);

/* Register information */
static SYMBOL *charreg[32], *shortreg[32], *intreg[32], *longreg[32], *fltreg[32];
static SYMBOL *charregw, *shortregw, *intregw, *longregw, *fltregw;

static int cseg;  /* current segment */
static int leafargs, retsize;
static bool_t noresb;
static char rtimp[RT_MAXCOUNT];
%}
%start stmt

%term CNSTF4=4113
%term CNSTF8=8209
%term CNSTI1=1045
%term CNSTI2=2069
%term CNSTI4=4117
%term CNSTI8=8213
%term CNSTP4=4119
%term CNSTU1=1046
%term CNSTU2=2070
%term CNSTU4=4118
%term CNSTU8=8214

%term ARGB=41
%term ARGF4=4129
%term ARGF8=8225
%term ARGI4=4133
%term ARGI8=8229
%term ARGP4=4135
%term ARGU4=4134
%term ARGU8=8230

%term ASGNB=57
%term ASGNF4=4145
%term ASGNF8=8241
%term ASGNI1=1077
%term ASGNI2=2101
%term ASGNI4=4149
%term ASGNI8=8245
%term ASGNP4=4151
%term ASGNU1=1078
%term ASGNU2=2102
%term ASGNU4=4150
%term ASGNU8=8246

%term INDIRB=73
%term INDIRF4=4161
%term INDIRF8=8257
%term INDIRI1=1093
%term INDIRI2=2117
%term INDIRI4=4165
%term INDIRI8=8261
%term INDIRP4=4167
%term INDIRU1=1094
%term INDIRU2=2118
%term INDIRU4=4166
%term INDIRU8=8262

%term CVFF4=4209
%term CVFF8=8305
%term CVFI4=4213
%term CVFI8=8309

%term CVIF4=4225
%term CVIF8=8321
%term CVII1=1157
%term CVII2=2181
%term CVII4=4229
%term CVII8=8325
%term CVIU1=1158
%term CVIU2=2182
%term CVIU4=4230
%term CVIU8=8326

%term CVPU4=4246

%term CVUI1=1205
%term CVUI2=2229
%term CVUI4=4277
%term CVUI8=8373
%term CVUP4=4279
%term CVUU1=1206
%term CVUU2=2230
%term CVUU4=4278
%term CVUU8=8374

%term NEGF4=4289
%term NEGF8=8385
%term NEGI4=4293
%term NEGI8=8389

%term CALLB=217
%term CALLF4=4305
%term CALLF8=8401
%term CALLI4=4309
%term CALLI8=8405
%term CALLP4=4311
%term CALLU4=4310
%term CALLU8=8406
%term CALLV=216

%term RETF4=4337
%term RETF8=8433
%term RETI4=4341
%term RETI8=8437
%term RETP4=4343
%term RETU4=4342
%term RETU8=8438
%term RETV=248

%term ADDRGP4=4359

%term ADDRFP4=4375

%term ADDRLP4=4391

%term ADDF4=4401
%term ADDF8=8497
%term ADDI4=4405
%term ADDI8=8501
%term ADDP4=4407
%term ADDU4=4406
%term ADDU8=8502

%term SUBF4=4417
%term SUBF8=8513
%term SUBI4=4421
%term SUBI8=8517
%term SUBP4=4423
%term SUBU4=4422
%term SUBU8=8518

%term LSHI4=4437
%term LSHI8=8533
%term LSHU4=4438
%term LSHU8=8534

%term MODI4=4453
%term MODI8=8549
%term MODU4=4454
%term MODU8=8550

%term RSHI4=4469
%term RSHI8=8565
%term RSHU4=4470
%term RSHU8=8566

%term BANDI4=4485
%term BANDI8=8581
%term BANDU4=4486
%term BANDU8=8582

%term BCOMI4=4501
%term BCOMI8=8597
%term BCOMU4=4502
%term BCOMU8=8598

%term BORI4=4517
%term BORI8=8613
%term BORU4=4518
%term BORU8=8614

%term BXORI4=4533
%term BXORI8=8629
%term BXORU4=4534
%term BXORU8=8630

%term DIVF4=4545
%term DIVF8=8641
%term DIVI4=4549
%term DIVI8=8645
%term DIVU4=4550
%term DIVU8=8646

%term MULF4=4561
%term MULF8=8657
%term MULI4=4565
%term MULI8=8661
%term MULU4=4566
%term MULU8=8662

%term EQF4=4577
%term EQF8=8673
%term EQI4=4581
%term EQI8=8677
%term EQU4=4582
%term EQU8=8678

%term GEF4=4593
%term GEF8=8689
%term GEI4=4597
%term GEI8=8693
%term GEU4=4598
%term GEU8=8694

%term GTF4=4609
%term GTF8=8705
%term GTI4=4613
%term GTI8=8709
%term GTU4=4614
%term GTU8=8710

%term LEF4=4625
%term LEF8=8721
%term LEI4=4629
%term LEI8=8725
%term LEU4=4630
%term LEU8=8726

%term LTF4=4641
%term LTF8=8737
%term LTI4=4645
%term LTI8=8741
%term LTU4=4646
%term LTU8=8742

%term NEF4=4657
%term NEF8=8753
%term NEI4=4661
%term NEI8=8757
%term NEU4=4662
%term NEU8=8758

%term JUMPV=584

%term LABELV=600

%term CBOOLU1=1638

%term CEQI4=4725
%term CEQU4=4726

%term CGEI4=4741
%term CGEU4=4742

%term CGTI4=4757
%term CGTU4=4758

%term CLEI4=4773
%term CLEU4=4774

%term CLTI4=4789
%term CLTU4=4790

%term CNEI4=4805
%term CNEU4=4806

%term INTRIN1F4=4817
%term INTRIN1F8=8913
%term INTRIN1I1=1749
%term INTRIN1I2=2773
%term INTRIN1I4=4821
%term INTRIN1I8=8917
%term INTRIN1P4=4823
%term INTRIN1U1=1750
%term INTRIN1U2=2774
%term INTRIN1U4=4822
%term INTRIN1U8=8918
%term INTRIN1V=728

%term INTRIN1SF4=4833
%term INTRIN1SF8=8929
%term INTRIN1SI1=1765
%term INTRIN1SI2=2789
%term INTRIN1SI4=4837
%term INTRIN1SI8=8933
%term INTRIN1SP4=4839
%term INTRIN1SU1=1766
%term INTRIN1SU2=2790
%term INTRIN1SU4=4838
%term INTRIN1SU8=8934
%term INTRIN1SV=744

%term INTRIN2F4=4849
%term INTRIN2F8=8945
%term INTRIN2I1=1781
%term INTRIN2I2=2805
%term INTRIN2I4=4853
%term INTRIN2I8=8949
%term INTRIN2P4=4855
%term INTRIN2U1=1782
%term INTRIN2U2=2806
%term INTRIN2U4=4854
%term INTRIN2U8=8950
%term INTRIN2V=760

%term INTRIN2SF4=4865
%term INTRIN2SF8=8961
%term INTRIN2SI1=1797
%term INTRIN2SI2=2821
%term INTRIN2SI4=4869
%term INTRIN2SI8=8965
%term INTRIN2SP4=4871
%term INTRIN2SU1=1798
%term INTRIN2SU2=2822
%term INTRIN2SU4=4870
%term INTRIN2SU8=8966
%term INTRIN2SV=776

%term LOADB=233
%term LOADF4=4321
%term LOADF8=8417
%term LOADI1=1253
%term LOADI2=2277
%term LOADI4=4325
%term LOADI8=8421
%term LOADP4=4327
%term LOADU1=1254
%term LOADU2=2278
%term LOADU4=4326
%term LOADU8=8422

%term VREGP=887
%%
reg: INDIRI1(VREGP)  "# read register\n"
reg: INDIRU1(VREGP)  "# read register\n"
reg: INDIRI2(VREGP)  "# read register\n"
reg: INDIRU2(VREGP)  "# read register\n"
reg: INDIRI4(VREGP)  "# read register\n"
reg: INDIRU4(VREGP)  "# read register\n"
reg: INDIRP4(VREGP)  "# read register\n"
reg: INDIRF4(VREGP)  "# read register\n"
reg: INDIRF8(VREGP)  "# read register\n"
reg: INDIRI8(VREGP)  "# read register\n"
reg: INDIRU8(VREGP)  "# read register\n"

stmt: ASGNI1(VREGP,reg)  "# write register\n"
stmt: ASGNU1(VREGP,reg)  "# write register\n"
stmt: ASGNI2(VREGP,reg)  "# write register\n"
stmt: ASGNU2(VREGP,reg)  "# write register\n"
stmt: ASGNI4(VREGP,reg)  "# write register\n"
stmt: ASGNU4(VREGP,reg)  "# write register\n"
stmt: ASGNP4(VREGP,reg)  "# write register\n"
stmt: ASGNF4(VREGP,reg)  "# write register\n"
stmt: ASGNF8(VREGP,reg)  "# write register\n"
stmt: ASGNI8(VREGP,reg)  "# write register\n"
stmt: ASGNU8(VREGP,reg)  "# write register\n"

con: CNSTI1  "%a"
con: CNSTU1  "%a"
con: CNSTI2  "%a"
con: CNSTU2  "%a"
con: CNSTI4  "%a"
con: CNSTU4  "%a"
con: CNSTP4  "%a"
reg: CNSTI8  "#\n"  2
reg: CNSTU8  "#\n"  2

stmt: reg  ""

acon: ADDRGP4  "(%a)"
acon: con  "(%0)"

base: ADDRGP4  "(%a)"
base: reg  "%0"
base: ADDI4(reg,acon)  "%0+%1"
base: ADDU4(reg,acon)  "%0+%1"
base: ADDP4(reg,acon)  "%0+%1"
base: ADDRFP4  "#"
base: ADDRLP4  "ebp+(%a)"

con1: CNSTI4  "1"  range(a,1,1)
con1: CNSTU4  "1"  range(a,1,1)
con2: CNSTI4  "2"  range(a,2,2)
con2: CNSTU4  "2"  range(a,2,2)
con3: CNSTI4  "3"  range(a,3,3)
con3: CNSTU4  "3"  range(a,3,3)

index: reg  "%0"
index: LSHI4(reg,con1)  "%0*2"
index: LSHI4(reg,con2)  "%0*4"
index: LSHI4(reg,con3)  "%0*8"
index: LSHU4(reg,con1)  "%0*2"
index: LSHU4(reg,con2)  "%0*4"
index: LSHU4(reg,con3)  "%0*8"

addr: base  "[%0]"
addr: ADDI4(index,base)  "[%1+%0]"
addr: ADDU4(index,base)  "[%1+%0]"
addr: ADDP4(index,base)  "[%1+%0]"
addr: index  "[%0]"

;; added 03-09-04
addr: ADDI4(ADDI4(index,reg),acon)  "[%1+%0+%2]"
addr: ADDU4(ADDU4(index,reg),acon)  "[%1+%0+%2]"
addr: ADDP4(ADDP4(index,reg),acon)  "[%1+%0+%2]"
addr: SUBI4(ADDI4(index,reg),acon)  "[%1+%0-%2]"
addr: SUBU4(ADDU4(index,reg),acon)  "[%1+%0-%2]"
addr: SUBP4(ADDP4(index,reg),acon)  "[%1+%0-%2]"

;; added 03-09-04
addr: ADDP4(ADDI4(index,acon),reg)  "[%2+%0+%1]"
addr: ADDP4(ADDU4(index,acon),reg)  "[%2+%0+%1]"
addr: ADDP4(ADDP4(index,acon),reg)  "[%2+%0+%1]"
addr: ADDP4(SUBI4(index,acon),reg)  "[%2+%0-%1]"
addr: ADDP4(SUBU4(index,acon),reg)  "[%2+%0-%1]"
addr: ADDP4(SUBP4(index,acon),reg)  "[%2+%0-%1]"

;; added
addr: ADDI4(index,acon)  "[%0+%1]"
addr: ADDU4(index,acon)  "[%0+%1]"
addr: ADDP4(index,acon)  "[%0+%1]"
addr: SUBI4(index,acon)  "[%0-%1]"
addr: SUBU4(index,acon)  "[%0-%1]"
addr: SUBP4(index,acon)  "[%0-%1]"

;; need INDIRB(addr) for dllimport of arrays.
mem: INDIRB(addr)   "dword %0"
mem: INDIRI1(addr)  "byte %0"
mem: INDIRI2(addr)  "word %0"
mem: INDIRI4(addr)  "dword %0"
mem: INDIRU1(addr)  "byte %0"
mem: INDIRU2(addr)  "word %0"
mem: INDIRU4(addr)  "dword %0"
mem: INDIRP4(addr)  "dword %0"

;; long long safe address modes (04-07-07).
laddr: ADDRGP4  "(%a)"
laddr: ADDRFP4  "#"
laddr: ADDRLP4  "ebp+(%a)"
laddr: con  "(%0)"
laddr: reg  "%0"
laddr: ADDI4(reg,acon)  "%0+%1"
laddr: ADDU4(reg,acon)  "%0+%1"
laddr: ADDP4(reg,acon)  "%0+%1"

reg: INDIRI8(laddr)  "#\n"
reg: INDIRU8(laddr)  "#\n"

rc: reg  "%0"
rc: con  "%0"

mr: reg  "%0"
mr: mem  "%0"

mrc0: mem  "%0"
mrc0: rc   "%0"
mrc1: mem  "%0"  1
mrc1: rc   "%0"
mrc3: mem  "%0"  3
mrc3: rc   "%0"

;; We would love to use "mov reg,ADDRGP4", but LCC won't allow it. Bummer.
reg: addr  "lea %c,%0\n"  1
reg: mrc0  "mov %c,%0\n"  1

;; we think move() is bad for long long's - but no real proof.
reg: LOADI1(reg)  "# move\n"  1
reg: LOADI2(reg)  "# move\n"  1
reg: LOADI4(reg)  "# move\n"  move(a)
reg: LOADI8(reg)  "# move\n"  1
reg: LOADU1(reg)  "# move\n"  1
reg: LOADU2(reg)  "# move\n"  1
reg: LOADU4(reg)  "# move\n"  move(a)
reg: LOADU8(reg)  "# move\n"  1
reg: LOADP4(reg)  "# move\n"  move(a)

;; all binary operators, beginning with a question mark, should also contain
;; the reversed form after another question mark (for reg,reg cases). this will
;; handle a = b - a. This scheme is the best, and was revised 04-08-26.

reg: ADDI4(reg,mrc1)  "?mov %c,%0\nadd %c,%1\n?mov %c,%1\nadd %c,%0\n"  1
reg: ADDU4(reg,mrc1)  "?mov %c,%0\nadd %c,%1\n?mov %c,%1\nadd %c,%0\n"  1
reg: ADDP4(reg,mrc1)  "?mov %c,%0\nadd %c,%1\n?mov %c,%1\nadd %c,%0\n"  1
reg: SUBI4(reg,mrc1)  "?mov %c,%0\nsub %c,%1\n?mov %c,%1\nneg %c\nadd %c,%0\n"  1
reg: SUBU4(reg,mrc1)  "?mov %c,%0\nsub %c,%1\n?mov %c,%1\nneg %c\nadd %c,%0\n"  1
reg: SUBP4(reg,mrc1)  "?mov %c,%0\nsub %c,%1\n?mov %c,%1\nneg %c\nadd %c,%0\n"  1
reg: BANDI4(reg,mrc1)  "?mov %c,%0\nand %c,%1\n?mov %c,%1\nand %c,%0\n"  1
reg: BANDU4(reg,mrc1)  "?mov %c,%0\nand %c,%1\n?mov %c,%1\nand %c,%0\n"  1
reg: BORI4(reg,mrc1)  "?mov %c,%0\nor %c,%1\n?mov %c,%1\nor %c,%0\n"  1
reg: BORU4(reg,mrc1)  "?mov %c,%0\nor %c,%1\n?mov %c,%1\nor %c,%0\n"  1
reg: BXORI4(reg,mrc1)  "?mov %c,%0\nxor %c,%1\n?mov %c,%1\nxor %c,%0\n"  1
reg: BXORU4(reg,mrc1)  "?mov %c,%0\nxor %c,%1\n?mov %c,%1\nxor %c,%0\n"  1

;; added 04-07-09.
reg: ADDU4(LOADU4(reg),LOADU4(reg))  "?mov %c,%0\nadd %c,%1\n?mov %c,%1\nadd %c,%0\n"
reg: SUBU4(LOADU4(reg),LOADU4(reg))  "?mov %c,%0\nsub %c,%1\n?mov %c,%1\nneg %c\nadd %c,%0\n"

reg: ADDI8(reg,reg)  "# ADDI8\n"  4
reg: ADDU8(reg,reg)  "# ADDU8\n"  4
reg: SUBI8(reg,reg)  "# SUBI8\n"  4
reg: SUBU8(reg,reg)  "# SUBU8\n"  4
reg: BANDI8(reg,reg)  "# BANDI8\n"  4
reg: BANDU8(reg,reg)  "# BANDU8\n"  4
reg: BORI8(reg,reg)  "# BORI8\n"  4
reg: BORU8(reg,reg)  "# BORU8\n"  4
reg: BXORI8(reg,reg)  "# BXORI8\n"  4
reg: BXORU8(reg,reg)  "# BXORU8\n"  4

;; lower cost to avoid assigning const to reg, and then add.
reg: ADDI8(reg,CNSTI8)  "# ADDI8C\n"  2
reg: ADDU8(reg,CNSTU8)  "# ADDU8C\n"  2
reg: SUBI8(reg,CNSTI8)  "# SUBI8C\n"  2
reg: SUBU8(reg,CNSTU8)  "# SUBU8C\n"  2
reg: BANDI8(reg,CNSTI8)  "# BANDI8C\n"  2
reg: BANDU8(reg,CNSTU8)  "# BANDU8C\n"  2
reg: BORI8(reg,CNSTI8)  "# BORI8C\n"  2
reg: BORU8(reg,CNSTU8)  "# BORU8C\n"  2
reg: BXORI8(reg,CNSTI8)  "# BXORI8C\n"  2
reg: BXORU8(reg,CNSTU8)  "# BXORU8C\n"  2

;; added
conm1: CNSTI4  "-1"  range(a,-1,-1)
conm1: CNSTU4  "-1"  range(a,-1,-1)

stmt: ASGNI4(addr,ADDI4(mem,con1))  "inc %1\n"  memop(a)
stmt: ASGNU4(addr,ADDU4(mem,con1))  "inc %1\n"  memop(a)
stmt: ASGNP4(addr,ADDP4(mem,con1))  "inc %1\n"  memop(a)
stmt: ASGNI4(addr,SUBI4(mem,con1))  "dec %1\n"  memop(a)
stmt: ASGNU4(addr,SUBU4(mem,con1))  "dec %1\n"  memop(a)
stmt: ASGNP4(addr,SUBP4(mem,con1))  "dec %1\n"  memop(a)
stmt: ASGNI4(addr,ADDI4(mem,conm1))  "dec %1\n"  memop(a)
stmt: ASGNU4(addr,ADDU4(mem,conm1))  "dec %1\n"  memop(a)
stmt: ASGNP4(addr,ADDP4(mem,conm1))  "dec %1\n"  memop(a)
stmt: ASGNI4(addr,SUBI4(mem,conm1))  "inc %1\n"  memop(a)
stmt: ASGNU4(addr,SUBU4(mem,conm1))  "inc %1\n"  memop(a)
stmt: ASGNP4(addr,SUBP4(mem,conm1))  "inc %1\n"  memop(a)
stmt: ASGNI4(addr,ADDI4(mem,rc))  "add %1,%2\n"  memop(a)
stmt: ASGNI4(addr,SUBI4(mem,rc))  "sub %1,%2\n"  memop(a)
stmt: ASGNU4(addr,ADDU4(mem,rc))  "add %1,%2\n"  memop(a)
stmt: ASGNU4(addr,SUBU4(mem,rc))  "sub %1,%2\n"  memop(a)
stmt: ASGNI4(addr,BANDI4(mem,rc))  "and %1,%2\n"  memop(a)
stmt: ASGNU4(addr,BANDU4(mem,rc))  "and %1,%2\n"  memop(a)
stmt: ASGNI4(addr,BORI4(mem,rc))  "or %1,%2\n"   memop(a)
stmt: ASGNU4(addr,BORU4(mem,rc))  "or %1,%2\n"   memop(a)
stmt: ASGNI4(addr,BXORI4(mem,rc))  "xor %1,%2\n"  memop(a)
stmt: ASGNU4(addr,BXORU4(mem,rc))  "xor %1,%2\n"  memop(a)

;; signed byte and word (04-03-20).
stmt: ASGNI1(addr,LOADI1(ADDI4(CVII4(INDIRI1(addr)),con1)))  "inc byte %1\n"  memop2(a)
stmt: ASGNI2(addr,LOADI2(ADDI4(CVII4(INDIRI2(addr)),con1)))  "inc word %1\n"  memop2(a)
stmt: ASGNI1(addr,LOADI1(SUBI4(CVII4(INDIRI1(addr)),con1)))  "dec byte %1\n"  memop2(a)
stmt: ASGNI2(addr,LOADI2(SUBI4(CVII4(INDIRI2(addr)),con1)))  "dec word %1\n"  memop2(a)
stmt: ASGNI1(addr,LOADI1(ADDI4(CVII4(INDIRI1(addr)),conm1)))  "dec byte %1\n"  memop2(a)
stmt: ASGNI2(addr,LOADI2(ADDI4(CVII4(INDIRI2(addr)),conm1)))  "dec word %1\n"  memop2(a)
stmt: ASGNI1(addr,LOADI1(SUBI4(CVII4(INDIRI1(addr)),conm1)))  "inc byte %1\n"  memop2(a)
stmt: ASGNI2(addr,LOADI2(SUBI4(CVII4(INDIRI2(addr)),conm1)))  "inc word %1\n"  memop2(a)
stmt: ASGNI1(addr,LOADI1(ADDI4(CVII4(INDIRI1(addr)),conb)))  "add byte %1,%2\n"  memop2(a)
stmt: ASGNI2(addr,LOADI2(ADDI4(CVII4(INDIRI2(addr)),conw)))  "add word %1,%2\n"  memop2(a)
stmt: ASGNI1(addr,LOADI1(SUBI4(CVII4(INDIRI1(addr)),conb)))  "sub byte %1,%2\n"  memop2(a)
stmt: ASGNI2(addr,LOADI2(SUBI4(CVII4(INDIRI2(addr)),conw)))  "sub word %1,%2\n"  memop2(a)
stmt: ASGNI1(addr,LOADI1(BANDI4(CVII4(INDIRI1(addr)),conb)))  "and byte %1,%2\n"  memop2(a)
stmt: ASGNI2(addr,LOADI2(BANDI4(CVII4(INDIRI2(addr)),conw)))  "and word %1,%2\n"  memop2(a)
stmt: ASGNI1(addr,LOADI1(BORI4(CVII4(INDIRI1(addr)),conb)))  "or byte %1,%2\n"  memop2(a)
stmt: ASGNI2(addr,LOADI2(BORI4(CVII4(INDIRI2(addr)),conw)))  "or word %1,%2\n"  memop2(a)
stmt: ASGNI1(addr,LOADI1(BXORI4(CVII4(INDIRI1(addr)),conb)))  "xor byte %1,%2\n"  memop2(a)
stmt: ASGNI2(addr,LOADI2(BXORI4(CVII4(INDIRI2(addr)),conw)))  "xor word %1,%2\n"  memop2(a)
stmt: ASGNI1(addr,LOADI1(BCOMI4(CVII4(INDIRI1(addr)))))  "not byte %1\n"  memop2(a)
stmt: ASGNI2(addr,LOADI2(BCOMI4(CVII4(INDIRI2(addr)))))  "not word %1\n"  memop2(a)
stmt: ASGNI1(addr,LOADI1(NEGI4(CVII4(INDIRI1(addr)))))  "neg byte %1\n"  memop2(a)
stmt: ASGNI2(addr,LOADI2(NEGI4(CVII4(INDIRI2(addr)))))  "neg word %1\n"  memop2(a)

;; unsigned byte and word (04-03-20).
stmt: ASGNU1(addr,LOADU1(LOADU4(ADDI4(CVUI4(INDIRU1(addr)),con1))))  "inc byte %1\n"  memop3(a)
stmt: ASGNU2(addr,LOADU2(LOADU4(ADDI4(CVUI4(INDIRU2(addr)),con1))))  "inc word %1\n"  memop3(a)
stmt: ASGNU1(addr,LOADU1(LOADU4(SUBI4(CVUI4(INDIRU1(addr)),con1))))  "dec byte %1\n"  memop3(a)
stmt: ASGNU2(addr,LOADU2(LOADU4(SUBI4(CVUI4(INDIRU2(addr)),con1))))  "dec word %1\n"  memop3(a)
stmt: ASGNU1(addr,LOADU1(LOADU4(ADDI4(CVUI4(INDIRU1(addr)),conm1))))  "dec byte %1\n"  memop3(a)
stmt: ASGNU2(addr,LOADU2(LOADU4(ADDI4(CVUI4(INDIRU2(addr)),conm1))))  "dec word %1\n"  memop3(a)
stmt: ASGNU1(addr,LOADU1(LOADU4(SUBI4(CVUI4(INDIRU1(addr)),conm1))))  "inc byte %1\n"  memop3(a)
stmt: ASGNU2(addr,LOADU2(LOADU4(SUBI4(CVUI4(INDIRU2(addr)),conm1))))  "inc word %1\n"  memop3(a)
stmt: ASGNU1(addr,LOADU1(LOADU4(ADDI4(CVUI4(INDIRU1(addr)),conb))))  "add byte %1,%2\n"  memop3(a)
stmt: ASGNU2(addr,LOADU2(LOADU4(ADDI4(CVUI4(INDIRU2(addr)),conw))))  "add word %1,%2\n"  memop3(a)
stmt: ASGNU1(addr,LOADU1(LOADU4(SUBI4(CVUI4(INDIRU1(addr)),conb))))  "sub byte %1,%2\n"  memop3(a)
stmt: ASGNU2(addr,LOADU2(LOADU4(SUBI4(CVUI4(INDIRU2(addr)),conw))))  "sub word %1,%2\n"  memop3(a)
stmt: ASGNU1(addr,LOADU1(LOADU4(BANDI4(CVUI4(INDIRU1(addr)),conb))))  "and byte %1,%2\n"  memop3(a)
stmt: ASGNU2(addr,LOADU2(LOADU4(BANDI4(CVUI4(INDIRU2(addr)),conw))))  "and word %1,%2\n"  memop3(a)
stmt: ASGNU1(addr,LOADU1(LOADU4(BORI4(CVUI4(INDIRU1(addr)),conb))))  "or byte %1,%2\n"  memop3(a)
stmt: ASGNU2(addr,LOADU2(LOADU4(BORI4(CVUI4(INDIRU2(addr)),conw))))  "or word %1,%2\n"  memop3(a)
stmt: ASGNU1(addr,LOADU1(LOADU4(BXORI4(CVUI4(INDIRU1(addr)),conb))))  "xor byte %1,%2\n"  memop3(a)
stmt: ASGNU2(addr,LOADU2(LOADU4(BXORI4(CVUI4(INDIRU2(addr)),conw))))  "xor word %1,%2\n"  memop3(a)
stmt: ASGNU1(addr,LOADU1(LOADU4(BCOMI4(CVUI4(INDIRU1(addr))))))  "not byte %1\n"  memop3(a)
stmt: ASGNU2(addr,LOADU2(LOADU4(BCOMI4(CVUI4(INDIRU2(addr))))))  "not word %1\n"  memop3(a)

reg: BCOMI4(reg)  "?mov %c,%0\nnot %c\n"  2
reg: BCOMU4(reg)  "?mov %c,%0\nnot %c\n"  2
reg: NEGI4(reg)   "?mov %c,%0\nneg %c\n"  2

reg: BCOMI8(reg)  "#\n"  4
reg: BCOMU8(reg)  "#\n"  4
reg: NEGI8(reg)   "#\n"  4

;; added 2000-06-15 (-unsigned)
reg: ADDU4(BCOMU4(reg),con1)  "?mov %c,%0\nneg %c\n"

stmt: ASGNI4(addr,BCOMI4(mem))  "not %1\n"  memop(a)
stmt: ASGNU4(addr,BCOMU4(mem))  "not %1\n"  memop(a)
stmt: ASGNI4(addr,NEGI4(mem))   "neg %1\n"  memop(a)

consh: CNSTI4  "%a"  range(a,0,31)

reg: LSHI4(reg,consh)  "?mov %c,%0\nshl %c,%1\n"  2
reg: LSHU4(reg,consh)  "?mov %c,%0\nshl %c,%1\n"  2
reg: RSHI4(reg,consh)  "?mov %c,%0\nsar %c,%1\n"  2
reg: RSHU4(reg,consh)  "?mov %c,%0\nshr %c,%1\n"  2

stmt: ASGNI4(addr,LSHI4(mem,consh))  "shl %1,%2\n"  memop(a)
stmt: ASGNI4(addr,LSHU4(mem,consh))  "shl %1,%2\n"  memop(a)
stmt: ASGNI4(addr,RSHI4(mem,consh))  "sar %1,%2\n"  memop(a)
stmt: ASGNI4(addr,RSHU4(mem,consh))  "shr %1,%2\n"  memop(a)
stmt: ASGNU4(addr,LSHU4(mem,consh))  "shl %1,%2\n"  memop(a)
stmt: ASGNU4(addr,RSHU4(mem,consh))  "shr %1,%2\n"  memop(a)

reg: LSHI4(reg,reg)  "?mov %c,%0\nmov ecx,%1\nshl %c,cl\n"  2
reg: LSHU4(reg,reg)  "?mov %c,%0\nmov ecx,%1\nshl %c,cl\n"  2
reg: RSHI4(reg,reg)  "?mov %c,%0\nmov ecx,%1\nsar %c,cl\n"  2
reg: RSHU4(reg,reg)  "?mov %c,%0\nmov ecx,%1\nshr %c,cl\n"  2

reg: LSHI8(reg,reg)  "# LSHI8\n"  20
reg: LSHU8(reg,reg)  "# LSHU8\n"  20
reg: RSHI8(reg,reg)  "# RSHI8\n"  20
reg: RSHU8(reg,reg)  "# RSHU8\n"  20

reg: LSHI8(reg,CNSTI4)  "# LSHI8C\n"  10
reg: LSHU8(reg,CNSTI4)  "# LSHU8C\n"  10
reg: RSHI8(reg,CNSTI4)  "# RSHI8C\n"  10
reg: RSHU8(reg,CNSTI4)  "# RSHU8C\n"  10

reg: MULI4(reg,mrc3)  "?mov %c,%0\nimul %c,%1\n?mov %c,%1\nimul %c,%0\n"  14
reg: MULI4(con,mr)  "imul %c,%1,%0\n"  13
reg: MULI4(mr,con)  "imul %c,%0,%1\n"  13
reg: MULU4(reg,mr)  "mul %1\n"  13
reg: DIVI4(reg,reg)  "cdq\nidiv %1\n"  43
reg: DIVI4(reg,con)  "# DIVI4C\n"  (options.pragmaopt == MAXSPEED ? 0 : LBURG_MAX)
reg: DIVU4(reg,reg)  "xor edx,edx\ndiv %1\n"  40
reg: DIVU4(reg,con)  "# DIVU4C\n"  (options.pragmaopt == MAXSPEED ? 0 : LBURG_MAX)
reg: MODI4(reg,reg)  "cdq\nidiv %1\n"  43
reg: MODU4(reg,reg)  "xor edx,edx\ndiv %1\n"  40

reg: MULI8(reg,reg)  "# MULI8\n"  20
reg: MULU8(reg,reg)  "# MULU8\n"  20
reg: DIVI8(reg,reg)  "# DIVI8\n"  20
reg: DIVU8(reg,reg)  "# DIVU8\n"  20
reg: MODI8(reg,reg)  "# MODI8\n"  20
reg: MODU8(reg,reg)  "# MODU8\n"  20

reg: MULI8(reg,CNSTI8)  "# MULI8C\n"  10
reg: MULU8(reg,CNSTU8)  "# MULU8C\n"  10
reg: DIVI8(reg,CNSTI8)  "# DIVI8C\n"  10
reg: DIVU8(reg,CNSTU8)  "# DIVU8C\n"  10
reg: MODI8(reg,CNSTI8)  "# MODI8C\n"  10
reg: MODU8(reg,CNSTU8)  "# MODU8C\n"  10

reg: CVPU4(reg)  "mov %c,%0\n"  move(a)
reg: CVUP4(reg)  "mov %c,%0\n"  move(a)
reg: CVII4(INDIRI1(addr))  "movsx %c,byte %0\n"  3
reg: CVII4(INDIRI2(addr))  "movsx %c,word %0\n"  3
reg: CVUU4(INDIRU1(addr))  "movzx %c,byte %0\n"  3
reg: CVUU4(INDIRU2(addr))  "movzx %c,word %0\n"  3
reg: CVIU4(INDIRI1(addr))  "movsx %c,byte %0\n"  3
reg: CVIU4(INDIRI2(addr))  "movsx %c,word %0\n"  3
reg: CVUI4(INDIRU1(addr))  "movzx %c,byte %0\n"  3
reg: CVUI4(INDIRU2(addr))  "movzx %c,word %0\n"  3

;; added 04-12-25
reg: CVUI4(LOADU1(LOADU4(CVII4(INDIRI1(addr)))))  "movzx %c,byte %0\n"  3
reg: CVUI4(LOADU2(LOADU4(CVII4(INDIRI2(addr)))))  "movzx %c,word %0\n"  3

reg: CVII4(reg)  "# extend\n"  3
reg: CVIU4(reg)  "# extend\n"  3
reg: CVUI4(reg)  "# extend\n"  3
reg: CVUU4(reg)  "# extend\n"  3

reg: CVII8(reg)  "# extend\n"  6
reg: CVIU8(reg)  "# extend\n"  6
reg: CVUI8(reg)  "# extend\n"  6
reg: CVUU8(reg)  "# extend\n"  6

reg: CVII1(reg)  "# truncate\n"  1
reg: CVII2(reg)  "# truncate\n"  1
reg: CVUU1(reg)  "# truncate\n"  1
reg: CVUU2(reg)  "# truncate\n"  1

;; special _Bool conversion.
reg: CBOOLU1(reg)  "# CBOOLU1\n"

;; added 04-12-10.
stmt: ASGNP4(addr,acon)  "mov dword %0,%1\n"

stmt: ASGNI1(addr,rc)  "mov byte %0,%1\n"   1
stmt: ASGNI2(addr,rc)  "mov word %0,%1\n"   1
stmt: ASGNI4(addr,rc)  "mov dword %0,%1\n"  1
stmt: ASGNU1(addr,rc)  "mov byte %0,%1\n"   1
stmt: ASGNU2(addr,rc)  "mov word %0,%1\n"   1
stmt: ASGNU4(addr,rc)  "mov dword %0,%1\n"  1
stmt: ASGNP4(addr,rc)  "mov dword %0,%1\n"  1
stmt: ASGNI8(laddr,reg)  "# write memory\n"  2
stmt: ASGNU8(laddr,reg)  "# write memory\n"  2
stmt: ASGNI8(laddr,CNSTI8)  "# write memory\n"  1
stmt: ASGNU8(laddr,CNSTU8)  "# write memory\n"  1

;; added fastcall handling 04-07-02.
stmt: ARGI4(reg)  "#\n"  (a->x.argno != 0 ? 0 : LBURG_MAX)
stmt: ARGU4(reg)  "#\n"  (a->x.argno != 0 ? 0 : LBURG_MAX)
stmt: ARGP4(reg)  "#\n"  (a->x.argno != 0 ? 0 : LBURG_MAX)

stmt: ARGI4(mrc3)  "push dword %0\n"  (a->x.argno != 0 ? LBURG_MAX : 1)
stmt: ARGI4(INDIRI4(addr))  "push dword %0\n"  (a->x.argno != 0 ? LBURG_MAX : options.pragmaopt == MINSPACE ? 0 : 4)
stmt: ARGU4(mrc3)  "push dword %0\n"  (a->x.argno != 0 ? LBURG_MAX : 1)
stmt: ARGU4(INDIRU4(addr))  "push dword %0\n"  (a->x.argno != 0 ? LBURG_MAX : options.pragmaopt == MINSPACE ? 0 : 4)
stmt: ARGP4(mrc3)  "push dword %0\n"  (a->x.argno != 0 ? LBURG_MAX : 1)
stmt: ARGP4(INDIRP4(addr))  "push dword %0\n"  (a->x.argno != 0 ? LBURG_MAX : options.pragmaopt == MINSPACE ? 0 : 4)
;; added "lea eax,@1 + push eax" -> "push @1" - added fastcall cost 04-07-02.
stmt: ARGP4(acon)  "push dword %0\n"  (a->x.argno != 0 ? LBURG_MAX : 0)

stmt: ASGNB(reg,INDIRB(reg))  "mov ecx,%a/4\nrep movsd\n"                (a->syms[0]->u.c.v.i > 8 && a->syms[0]->u.c.v.i % 4 == 0 ? 8 : LBURG_MAX)
stmt: ASGNB(reg,INDIRB(reg))  "mov ecx,%a/4\nrep movsd\nmovsb\n"         (a->syms[0]->u.c.v.i > 8 && a->syms[0]->u.c.v.i % 4 == 1 ? 8 : LBURG_MAX)
stmt: ASGNB(reg,INDIRB(reg))  "mov ecx,%a/4\nrep movsd\nmovsw\n"         (a->syms[0]->u.c.v.i > 8 && a->syms[0]->u.c.v.i % 4 == 2 ? 8 : LBURG_MAX)
stmt: ASGNB(reg,INDIRB(reg))  "mov ecx,%a/4\nrep movsd\nmovsw\nmovsb\n"  (a->syms[0]->u.c.v.i > 8 && a->syms[0]->u.c.v.i % 4 == 3 ? 8 : LBURG_MAX)
stmt: ASGNB(reg,INDIRB(reg))  "mov ecx,%a\nrep movsb\n"  12

;; very large structs (>= 4096 bytes).
stmt: ARGB(INDIRB(reg))  "mov eax,(%a+3)&(~3)\ncall ___chkstk\nmov edi,esp\nmov ecx,%a/4\nrep movsd\n"                (a->syms[0]->u.c.v.i >= 4096 && a->syms[0]->u.c.v.i % 4 == 0 ? (rtimp[RT_CHKSTK] = 4) : LBURG_MAX)
stmt: ARGB(INDIRB(reg))  "mov eax,(%a+3)&(~3)\ncall ___chkstk\nmov edi,esp\nmov ecx,%a/4\nrep movsd\nmovsb\n"         (a->syms[0]->u.c.v.i >= 4096 && a->syms[0]->u.c.v.i % 4 == 1 ? (rtimp[RT_CHKSTK] = 4) : LBURG_MAX)
stmt: ARGB(INDIRB(reg))  "mov eax,(%a+3)&(~3)\ncall ___chkstk\nmov edi,esp\nmov ecx,%a/4\nrep movsd\nmovsw\n"         (a->syms[0]->u.c.v.i >= 4096 && a->syms[0]->u.c.v.i % 4 == 2 ? (rtimp[RT_CHKSTK] = 4) : LBURG_MAX)
stmt: ARGB(INDIRB(reg))  "mov eax,(%a+3)&(~3)\ncall ___chkstk\nmov edi,esp\nmov ecx,%a/4\nrep movsd\nmovsw\nmovsb\n"  (a->syms[0]->u.c.v.i >= 4096 && a->syms[0]->u.c.v.i % 4 == 3 ? (rtimp[RT_CHKSTK] = 4) : LBURG_MAX)

;; large structs.
stmt: ARGB(INDIRB(reg))  "sub esp,(%a+3)&(~3)\nmov edi,esp\nmov ecx,%a/4\nrep movsd\n"                (a->syms[0]->u.c.v.i < 4096 && a->syms[0]->u.c.v.i > 8 && a->syms[0]->u.c.v.i % 4 == 0 ? 8 : LBURG_MAX)
stmt: ARGB(INDIRB(reg))  "sub esp,(%a+3)&(~3)\nmov edi,esp\nmov ecx,%a/4\nrep movsd\nmovsb\n"         (a->syms[0]->u.c.v.i < 4096 && a->syms[0]->u.c.v.i > 8 && a->syms[0]->u.c.v.i % 4 == 1 ? 8 : LBURG_MAX)
stmt: ARGB(INDIRB(reg))  "sub esp,(%a+3)&(~3)\nmov edi,esp\nmov ecx,%a/4\nrep movsd\nmovsw\n"         (a->syms[0]->u.c.v.i < 4096 && a->syms[0]->u.c.v.i > 8 && a->syms[0]->u.c.v.i % 4 == 2 ? 8 : LBURG_MAX)
stmt: ARGB(INDIRB(reg))  "sub esp,(%a+3)&(~3)\nmov edi,esp\nmov ecx,%a/4\nrep movsd\nmovsw\nmovsb\n"  (a->syms[0]->u.c.v.i < 4096 && a->syms[0]->u.c.v.i > 8 && a->syms[0]->u.c.v.i % 4 == 3 ? 8 : LBURG_MAX)
stmt: ARGB(INDIRB(reg))  "sub esp,(%a+3)&(~3)\nmov edi,esp\nmov ecx,%a\nrep movsb\n"                  (a->syms[0]->u.c.v.i < 4096 ? 12 : LBURG_MAX)

stmt: ARGI8(reg)  "#\n"
stmt: ARGI8(CNSTI8)  "#\n"
stmt: ARGU8(reg)  "#\n"
stmt: ARGU8(CNSTU8)  "#\n"

memf: INDIRF8(addr)  "qword %0"
memf: INDIRF4(addr)  "dword %0"
memf: CVFF8(INDIRF4(addr))  "dword %0"

reg: memf  "fld %0\n"  3

stmt: ASGNF8(addr,reg)  "fstp qword %0\n"  7
stmt: ASGNF4(addr,reg)  "fstp dword %0\n"  7
stmt: ASGNF4(addr,CVFF4(reg))  "fstp dword %0\n"  7

stmt: ARGF8(reg)  "sub esp,8\nfstp qword [esp]\n"
stmt: ARGF4(reg)  "sub esp,4\nfstp dword [esp]\n"

;; added "fld dword <FLT> + sub esp,4 + fstp dword [esp]" -> "push dword <FLT>"
stmt: ARGF4(INDIRF4(addr))  "push dword %0\n"

reg: NEGF8(reg)  "fchs\n"
reg: NEGF4(reg)  "fchs\n"

flt: memf  " %0"
flt: reg   "p st1,st0"
reg: ADDF8(reg,flt)  "fadd%1\n"
reg: ADDF4(reg,flt)  "fadd%1\n"
reg: DIVF8(reg,flt)  "fdiv%1\n"
reg: DIVF4(reg,flt)  "fdiv%1\n"
reg: MULF8(reg,flt)  "fmul%1\n"
reg: MULF4(reg,flt)  "fmul%1\n"
reg: SUBF8(reg,flt)  "fsub%1\n"
reg: SUBF4(reg,flt)  "fsub%1\n"

reg: CVFF8(reg)  "# CVFF8\n"
reg: CVFF4(reg)  "# CVFF4\n"
;; reg: CVFF4(reg)  "sub esp,4\nfstp dword [esp]\nfld dword [esp]\nadd esp,4\n"  12

;; __ftol() *limits* a LONG value, __ftoll() just chops (like Microsoft).
reg: CVFI4(reg)  "call ___ftoll\n"  (options.microsoft ? (rtimp[RT_FTOLL] = 31) : LBURG_MAX)
reg: CVFI4(reg)  "call ___ftol\n"   (options.microsoft ? LBURG_MAX : (rtimp[RT_FTOL] = 31))
reg: CVIF4(INDIRI4(addr))  "fild dword %0\n"  10
reg: CVIF8(INDIRI4(addr))  "fild dword %0\n"  10
reg: CVIF4(reg)  "# CVIF4\n"  12
reg: CVIF8(reg)  "# CVIF8\n"  12
reg: CVFI8(reg)  "call ___ftoll\n"  (rtimp[RT_FTOLL] = 31)
reg: CVIF4(INDIRI8(addr))  "fild qword %0\n"  10
reg: CVIF8(INDIRI8(addr))  "fild qword %0\n"  10

;;
;; Branch and call.
;;
addrj: ADDRGP4  "%a"
addrj: reg  "%0"  2
addrj: mem  "%0"  2

stmt: JUMPV(addrj)  "jmp near %0\n"  3
stmt: LABELV        "%a:\n"

stmt: CALLV(addrj)  "call %0\nadd esp,(%a+3)&(~3)\n"  popargs(a)
stmt: CALLV(addrj)  "call %0\n"  1

;; Floating point functions with ignored return values must still
;; pop the floating point stack. Note that these rules *must*
;; come before "reg: CALLF?()"
stmt: CALLF4(addrj)  "call %0\nadd esp,(%a+3)&(~3)\nfstp ST0\n"  popargs(a)
stmt: CALLF4(addrj)  "call %0\nfstp ST0\n"  1
stmt: CALLF8(addrj)  "call %0\nadd esp,(%a+3)&(~3)\nfstp ST0\n"  popargs(a)
stmt: CALLF8(addrj)  "call %0\nfstp ST0\n"  1

reg: CALLI4(addrj)  "call %0\nadd esp,(%a+3)&(~3)\n"  popargs(a)
reg: CALLI4(addrj)  "call %0\n"  1
reg: CALLU4(addrj)  "call %0\nadd esp,(%a+3)&(~3)\n"  popargs(a)
reg: CALLU4(addrj)  "call %0\n"  1
reg: CALLP4(addrj)  "call %0\nadd esp,(%a+3)&(~3)\n"  popargs(a)
reg: CALLP4(addrj)  "call %0\n"  1
reg: CALLF4(addrj)  "call %0\nadd esp,(%a+3)&(~3)\n"  popargs(a)
reg: CALLF4(addrj)  "call %0\n"  1
reg: CALLF8(addrj)  "call %0\nadd esp,(%a+3)&(~3)\n"  popargs(a)
reg: CALLF8(addrj)  "call %0\n"  1
reg: CALLI8(addrj)  "call %0\nadd esp,(%a+3)&(~3)\n"  popargs(a)
reg: CALLI8(addrj)  "call %0\n"  1
reg: CALLU8(addrj)  "call %0\nadd esp,(%a+3)&(~3)\n"  popargs(a)
reg: CALLU8(addrj)  "call %0\n"  1

stmt: RETI4(reg)  "# ret\n"
stmt: RETU4(reg)  "# ret\n"
stmt: RETP4(reg)  "# ret\n"
stmt: RETF4(reg)  "# ret\n"
stmt: RETF8(reg)  "# ret\n"
stmt: RETI8(reg)  "# ret\n"
stmt: RETU8(reg)  "# ret\n"

;;
;; Integer compares.
;;
stmt: EQI4(mem,rc)  "cmp %0,%1\nje near %a\n"  5
stmt: GEI4(mem,rc)  "cmp %0,%1\njge near %a\n"  5
stmt: GTI4(mem,rc)  "cmp %0,%1\njg near %a\n"  5
stmt: LEI4(mem,rc)  "cmp %0,%1\njle near %a\n"  5
stmt: LTI4(mem,rc)  "cmp %0,%1\njl near %a\n"  5
stmt: NEI4(mem,rc)  "cmp %0,%1\njne near %a\n"  5
stmt: EQU4(mem,rc)  "cmp %0,%1\nje near %a\n"  5
stmt: GEU4(mem,rc)  "cmp %0,%1\njae near %a\n"  5
stmt: GTU4(mem,rc)  "cmp %0,%1\nja near %a\n"  5
stmt: LEU4(mem,rc)  "cmp %0,%1\njbe near %a\n"  5
stmt: LTU4(mem,rc)  "cmp %0,%1\njb near %a\n"  5
stmt: NEU4(mem,rc)  "cmp %0,%1\njne near %a\n"  5

stmt: EQI4(reg,mrc1)  "cmp %0,%1\nje near %a\n"  4
stmt: GEI4(reg,mrc1)  "cmp %0,%1\njge near %a\n"  4
stmt: GTI4(reg,mrc1)  "cmp %0,%1\njg near %a\n"  4
stmt: LEI4(reg,mrc1)  "cmp %0,%1\njle near %a\n"  4
stmt: LTI4(reg,mrc1)  "cmp %0,%1\njl near %a\n"  4
stmt: NEI4(reg,mrc1)  "cmp %0,%1\njne near %a\n"  4
stmt: EQU4(reg,mrc1)  "cmp %0,%1\nje near %a\n"  4
stmt: GEU4(reg,mrc1)  "cmp %0,%1\njae near %a\n"  4
stmt: GTU4(reg,mrc1)  "cmp %0,%1\nja near %a\n"  4
stmt: LEU4(reg,mrc1)  "cmp %0,%1\njbe near %a\n"  4
stmt: LTU4(reg,mrc1)  "cmp %0,%1\njb near %a\n"  4
stmt: NEU4(reg,mrc1)  "cmp %0,%1\njne near %a\n"  4

stmt: EQI8(reg,reg)  "#\n"  8
stmt: GEI8(reg,reg)  "#\n"  8
stmt: GTI8(reg,reg)  "#\n"  8
stmt: LEI8(reg,reg)  "#\n"  8
stmt: LTI8(reg,reg)  "#\n"  8
stmt: NEI8(reg,reg)  "#\n"  8
stmt: EQU8(reg,reg)  "#\n"  8
stmt: GEU8(reg,reg)  "#\n"  8
stmt: GTU8(reg,reg)  "#\n"  8
stmt: LEU8(reg,reg)  "#\n"  8
stmt: LTU8(reg,reg)  "#\n"  8
stmt: NEU8(reg,reg)  "#\n"  8

stmt: EQI8(reg,CNSTI8)  "#\n"  4
stmt: GEI8(reg,CNSTI8)  "#\n"  4
stmt: GTI8(reg,CNSTI8)  "#\n"  4
stmt: LEI8(reg,CNSTI8)  "#\n"  4
stmt: LTI8(reg,CNSTI8)  "#\n"  4
stmt: NEI8(reg,CNSTI8)  "#\n"  4
stmt: EQU8(reg,CNSTU8)  "#\n"  4
stmt: GEU8(reg,CNSTU8)  "#\n"  4
stmt: GTU8(reg,CNSTU8)  "#\n"  4
stmt: LEU8(reg,CNSTU8)  "#\n"  4
stmt: LTU8(reg,CNSTU8)  "#\n"  4
stmt: NEU8(reg,CNSTU8)  "#\n"  4

;; signed char optimization (04-03-18).
stmt: EQI4(CVII4(INDIRI1(addr)),con)  "cmp byte %0,%1\nje near %a\n"  5
stmt: GEI4(CVII4(INDIRI1(addr)),con)  "cmp byte %0,%1\njge near %a\n"  5
stmt: GTI4(CVII4(INDIRI1(addr)),con)  "cmp byte %0,%1\njg near %a\n"  5
stmt: LEI4(CVII4(INDIRI1(addr)),con)  "cmp byte %0,%1\njle near %a\n"  5
stmt: LTI4(CVII4(INDIRI1(addr)),con)  "cmp byte %0,%1\njl near %a\n"  5
stmt: NEI4(CVII4(INDIRI1(addr)),con)  "cmp byte %0,%1\njne near %a\n"  5

;; unsigned char optimization (04-03-18).
stmt: EQI4(CVUI4(INDIRU1(addr)),con)  "cmp byte %0,%1\nje near %a\n"  5
stmt: GEI4(CVUI4(INDIRU1(addr)),con)  "cmp byte %0,%1\njae near %a\n"  5
stmt: GTI4(CVUI4(INDIRU1(addr)),con)  "cmp byte %0,%1\nja near %a\n"  5
stmt: LEI4(CVUI4(INDIRU1(addr)),con)  "cmp byte %0,%1\njbe near %a\n"  5
stmt: LTI4(CVUI4(INDIRU1(addr)),con)  "cmp byte %0,%1\njb near %a\n"  5
stmt: NEI4(CVUI4(INDIRU1(addr)),con)  "cmp byte %0,%1\njne near %a\n"  5

;; signed short optimization (04-03-18).
stmt: EQI4(CVUI4(INDIRI2(addr)),con)  "cmp word %0,%1\nje near %a\n"  5
stmt: GEI4(CVUI4(INDIRI2(addr)),con)  "cmp word %0,%1\njge near %a\n"  5
stmt: GTI4(CVUI4(INDIRI2(addr)),con)  "cmp word %0,%1\njg near %a\n"  5
stmt: LEI4(CVUI4(INDIRI2(addr)),con)  "cmp word %0,%1\njle near %a\n"  5
stmt: LTI4(CVUI4(INDIRI2(addr)),con)  "cmp word %0,%1\njl near %a\n"  5
stmt: NEI4(CVUI4(INDIRI2(addr)),con)  "cmp word %0,%1\njne near %a\n"  5

;; unsigned short (wchar_t) optimization (04-03-18).
stmt: EQI4(CVUI4(INDIRU2(addr)),con)  "cmp word %0,%1\nje near %a\n"  5
stmt: GEI4(CVUI4(INDIRU2(addr)),con)  "cmp word %0,%1\njae near %a\n"  5
stmt: GTI4(CVUI4(INDIRU2(addr)),con)  "cmp word %0,%1\nja near %a\n"  5
stmt: LEI4(CVUI4(INDIRU2(addr)),con)  "cmp word %0,%1\njbe near %a\n"  5
stmt: LTI4(CVUI4(INDIRU2(addr)),con)  "cmp word %0,%1\njb near %a\n"  5
stmt: NEI4(CVUI4(INDIRU2(addr)),con)  "cmp word %0,%1\njne near %a\n"  5

;; avoid movsx eax,al : test eax,eax : jcc label (04-03-18)
stmt: EQI4(CVII4(reg),con)  "cmp %0,%1\nje near %a\n"  4
stmt: GEI4(CVII4(reg),con)  "cmp %0,%1\njge near %a\n"  4
stmt: GTI4(CVII4(reg),con)  "cmp %0,%1\njg near %a\n"  4
stmt: LEI4(CVII4(reg),con)  "cmp %0,%1\njle near %a\n"  4
stmt: LTI4(CVII4(reg),con)  "cmp %0,%1\njl near %a\n"  4
stmt: NEI4(CVII4(reg),con)  "cmp %0,%1\njne near %a\n"  4

stmt: EQI4(CVUI4(reg),con)  "cmp %0,%1\nje near %a\n"  4
stmt: GEI4(CVUI4(reg),con)  "cmp %0,%1\njae near %a\n"  4
stmt: GTI4(CVUI4(reg),con)  "cmp %0,%1\nja near %a\n"  4
stmt: LEI4(CVUI4(reg),con)  "cmp %0,%1\njbe near %a\n"  4
stmt: LTI4(CVUI4(reg),con)  "cmp %0,%1\njb near %a\n"  4
stmt: NEI4(CVUI4(reg),con)  "cmp %0,%1\njne near %a\n"  4

;; avoid mov eax,ebx : cmp eax,nn : jcc label (04-03-23)
;; mainly for comparing pointers against NULL
stmt: EQU4(LOADU4(reg),con)  "cmp %0,%1\nje near %a\n"  4
stmt: NEU4(LOADU4(reg),con)  "cmp %0,%1\njne near %a\n"  4

;; avoid mov eax,ebx : mov edx,esi : cmp eax,edx : jcc label (04-03-23)
stmt: EQU4(LOADU4(reg),LOADU4(reg))  "cmp %0,%1\nje near %a\n"  4
stmt: GEU4(LOADU4(reg),LOADU4(reg))  "cmp %0,%1\njae near %a\n"  4
stmt: GTU4(LOADU4(reg),LOADU4(reg))  "cmp %0,%1\nja near %a\n"  4
stmt: LEU4(LOADU4(reg),LOADU4(reg))  "cmp %0,%1\njbe near %a\n"  4
stmt: LTU4(LOADU4(reg),LOADU4(reg))  "cmp %0,%1\njb near %a\n"  4
stmt: NEU4(LOADU4(reg),LOADU4(reg))  "cmp %0,%1\njne near %a\n"  4

con0: CNSTI4  "0"  range(a,0,0)
con0: CNSTU4  "0"  range(a,0,0)
conb: CNSTI4  "%a"  range(a,0,255)
conb: CNSTU4  "%a"  range(a,0,255)
conw: CNSTI4  "%a"  range(a,0,65535)
conw: CNSTU4  "%a"  range(a,0,65535)

;; BAND optimizations ( if (x & bits) )
stmt: NEI4(BANDI4(CVII4(INDIRI1(addr)),con),con0)  "test byte %0,%1\njne near %a\n"  5
stmt: EQI4(BANDI4(CVII4(INDIRI1(addr)),con),con0)  "test byte %0,%1\nje near %a\n"  5
stmt: NEI4(BANDI4(CVUI4(INDIRU1(addr)),con),con0)  "test byte %0,%1\njne near %a\n"  5
stmt: EQI4(BANDI4(CVUI4(INDIRU1(addr)),con),con0)  "test byte %0,%1\nje near %a\n"  5
stmt: NEI4(BANDI4(CVII4(INDIRI2(addr)),con),con0)  "test word %0,%1\njne near %a\n"  5
stmt: EQI4(BANDI4(CVII4(INDIRI2(addr)),con),con0)  "test word %0,%1\nje near %a\n"  5
stmt: NEI4(BANDI4(CVUI4(INDIRU2(addr)),con),con0)  "test word %0,%1\njne near %a\n"  5
stmt: EQI4(BANDI4(CVUI4(INDIRU2(addr)),con),con0)  "test word %0,%1\nje near %a\n"  5
;; not always needed to test entire dword
stmt: NEI4(BANDI4(INDIRI4(addr),conb),con0)  "test byte %0,%1\njne near %a\n"  5
stmt: EQI4(BANDI4(INDIRI4(addr),conb),con0)  "test byte %0,%1\nje near %a\n"  5
stmt: NEU4(BANDU4(INDIRU4(addr),conb),con0)  "test byte %0,%1\njne near %a\n"  5
stmt: EQU4(BANDU4(INDIRU4(addr),conb),con0)  "test byte %0,%1\nje near %a\n"  5
stmt: NEI4(BANDI4(INDIRI4(addr),conw),con0)  "test word %0,%1\njne near %a\n"  5
stmt: EQI4(BANDI4(INDIRI4(addr),conw),con0)  "test word %0,%1\nje near %a\n"  5
stmt: NEU4(BANDU4(INDIRU4(addr),conw),con0)  "test word %0,%1\njne near %a\n"  5
stmt: EQU4(BANDU4(INDIRU4(addr),conw),con0)  "test word %0,%1\nje near %a\n"  5

;; more BAND optimizations (added 04-07-19; reg->rc 04-12-21).
stmt: NEI4(BANDI4(reg,rc),con0)  "test %0,%1\njne near %a\n"  5
stmt: EQI4(BANDI4(reg,rc),con0)  "test %0,%1\nje near %a\n"  5
stmt: NEU4(BANDU4(reg,rc),con0)  "test %0,%1\njne near %a\n"  5
stmt: EQU4(BANDU4(reg,rc),con0)  "test %0,%1\nje near %a\n"  5

;;
;; Floating point compares.
;;
cmpf: memf  " %0"
cmpf: reg  "p"

stmt: EQF8(cmpf,reg)  "fcomp%0\nfnstsw ax\nsahf\nje near %a\n"
stmt: GEF8(cmpf,reg)  "fcomp%0\nfnstsw ax\nsahf\njbe near %a\n"
stmt: GTF8(cmpf,reg)  "fcomp%0\nfnstsw ax\nsahf\njb near %a\n"
stmt: LEF8(cmpf,reg)  "fcomp%0\nfnstsw ax\nsahf\njae near %a\n"
stmt: LTF8(cmpf,reg)  "fcomp%0\nfnstsw ax\nsahf\nja near %a\n"
stmt: NEF8(cmpf,reg)  "fcomp%0\nfnstsw ax\nsahf\njne near %a\n"
stmt: EQF4(cmpf,reg)  "fcomp%0\nfnstsw ax\nsahf\nje near %a\n"
stmt: GEF4(cmpf,reg)  "fcomp%0\nfnstsw ax\nsahf\njbe near %a\n"
stmt: GTF4(cmpf,reg)  "fcomp%0\nfnstsw ax\nsahf\njb near %a\n"
stmt: LEF4(cmpf,reg)  "fcomp%0\nfnstsw ax\nsahf\njae near %a\n"
stmt: LTF4(cmpf,reg)  "fcomp%0\nfnstsw ax\nsahf\nja near %a\n"
stmt: NEF4(cmpf,reg)  "fcomp%0\nfnstsw ax\nsahf\njne near %a\n"

;;
;; Optimized compares (added 04-03-08).
;;
reg: CEQI4(mem,rc)  "cmp %0,%1\nsete al\nand eax,1\n"  7
reg: CGEI4(mem,rc)  "cmp %0,%1\nsetge al\nand eax,1\n"  7
reg: CGTI4(mem,rc)  "cmp %0,%1\nsetg al\nand eax,1\n"  7
reg: CLEI4(mem,rc)  "cmp %0,%1\nsetle al\nand eax,1\n"  7
reg: CLTI4(mem,rc)  "cmp %0,%1\nsetl al\nand eax,1\n"  7
reg: CNEI4(mem,rc)  "cmp %0,%1\nsetne al\nand eax,1\n"  7
reg: CEQU4(mem,rc)  "cmp %0,%1\nsete al\nand eax,1\n"  7
reg: CGEU4(mem,rc)  "cmp %0,%1\nsetae al\nand eax,1\n"  7
reg: CGTU4(mem,rc)  "cmp %0,%1\nseta al\nand eax,1\n"  7
reg: CLEU4(mem,rc)  "cmp %0,%1\nsetbe al\nand eax,1\n"  7
reg: CLTU4(mem,rc)  "cmp %0,%1\nsetb al\nand eax,1\n"  7
reg: CNEU4(mem,rc)  "cmp %0,%1\nsetne al\nand eax,1\n"  7

reg: CEQI4(reg,mrc1)  "cmp %0,%1\nsete al\nand eax,1\n"  6
reg: CGEI4(reg,mrc1)  "cmp %0,%1\nsetge al\nand eax,1\n"  6
reg: CGTI4(reg,mrc1)  "cmp %0,%1\nsetg al\nand eax,1\n"  6
reg: CLEI4(reg,mrc1)  "cmp %0,%1\nsetle al\nand eax,1\n"  6
reg: CLTI4(reg,mrc1)  "cmp %0,%1\nsetl al\nand eax,1\n"  6
reg: CNEI4(reg,mrc1)  "cmp %0,%1\nsetne al\nand eax,1\n"  6
reg: CEQU4(reg,mrc1)  "cmp %0,%1\nsete al\nand eax,1\n"  6
reg: CGEU4(reg,mrc1)  "cmp %0,%1\nsetae al\nand eax,1\n"  6
reg: CGTU4(reg,mrc1)  "cmp %0,%1\nseta al\nand eax,1\n"  6
reg: CLEU4(reg,mrc1)  "cmp %0,%1\nsetbe al\nand eax,1\n"  6
reg: CLTU4(reg,mrc1)  "cmp %0,%1\nsetb al\nand eax,1\n"  6
reg: CNEU4(reg,mrc1)  "cmp %0,%1\nsetne al\nand eax,1\n"  6

;;
;; Intrinsics.
;;
;; intrinsic function with one argument (no side effects).
reg: INTRIN1I4(reg)  "# INTRIN1I4\n"
reg: INTRIN1U4(reg)  "# INTRIN1U4\n"
reg: INTRIN1P4(reg)  "# INTRIN1P4\n"
reg: INTRIN1F4(reg)  "# INTRIN1F4\n"
reg: INTRIN1F8(reg)  "# INTRIN1F8\n"

;; intrinsic function with two arguments (no side effects).
reg: INTRIN2I4(reg,reg)  "# INTRIN2I4\n"
reg: INTRIN2U4(reg,reg)  "# INTRIN2U4\n"
reg: INTRIN2P4(reg,reg)  "# INTRIN2P4\n"
reg: INTRIN2F4(reg,reg)  "# INTRIN2F4\n"
reg: INTRIN2F8(reg,reg)  "# INTRIN2F8\n"

;; intrinsic function with one argument (side effects).
reg: INTRIN1SI4(reg)  "# INTRIN1SI4\n"
reg: INTRIN1SU2(reg)  "# INTRIN1SU2\n"
reg: INTRIN1SU4(reg)  "# INTRIN1SU4\n"
reg: INTRIN1SP4(reg)  "# INTRIN1SP4\n"

;; intrinsic function with two arguments (side effects).
reg: INTRIN2SI4(reg,reg)  "# INTRIN2SI4\n"
reg: INTRIN2SU2(reg,reg)  "# INTRIN2SU2\n"
reg: INTRIN2SU4(reg,reg)  "# INTRIN2SU4\n"
reg: INTRIN2SP4(reg,reg)  "# INTRIN2SP4\n"
stmt: INTRIN2SV(reg,reg)   "# INTRIN2SV\n"

;; intrinsic function with no argument (side effects).
reg: INTRIN1SU8  "# INTRINSU8\n"
reg: INTRIN1SV  "# INTRINSV\n"

%%

/*
 * Generic peephole rules - make code smaller and/or faster.
 */
static const char *generic_rules[] = {
    "mov %1,%2", "lea %2,[%1+(1)]", NULL,                   "mov %1,%2", "inc %2", NULL,
    "mov %1,%2", "lea %2,[%1+(-1)]", NULL,                  "mov %1,%2", "dec %2", NULL,
    "mov %1,%2", "lea %1,[%2+(1)]", NULL,                   "mov %1,%2", "inc %1", NULL,  /* 04-03-30 */
    "mov %1,%2", "lea %1,[%2+(-1)]", NULL,                  "mov %1,%2", "dec %1", NULL,  /* 04-03-30 */
    "mov %1,%2", "sub %1,1", "mov %2,%1", NULL,             "dec %2", "mov %1,%2", NULL,
    "mov %1,%2", "add %1,1", "mov %2,%1", NULL,             "inc %2", "mov %1,%2", NULL,
    "mov %1,%2", "lea %2,[%1+(#3)]", NULL,                  "mov %1,%2", "add %2,#3", NULL,  /* 04-12-18 */
    "mov %1,%2", "lea %2,[%1-(#3)]", NULL,                  "mov %1,%2", "sub %2,#3", NULL,  /* 04-12-18 */
    "lea %1,[%2+(1)]", "mov %2,%1", NULL,                   "inc %2", "mov %1,%2", NULL,
    "lea %1,[%2+(-1)]", "mov %2,%1", NULL,                  "dec %2", "mov %1,%2", NULL,
    "lea %1,[%2-(1)]", "mov %2,%1", NULL,                   "dec %2", "mov %1,%2", NULL,  /* 04-03-10 */
    "lea %1,[%2-(-1)]", "mov %2,%1", NULL,                  "inc %2", "mov %1,%2", NULL,  /* 04-03-10 */
    "lea %1,[%1+(1)]", NULL,                                "inc %1", NULL,
    "lea %1,[%1+(-1)]", NULL,                               "dec %1", NULL,
    "lea %1,[%1-(1)]", NULL,                                "dec %1", NULL,     /* 03-09-01 */
    "lea %1,[%1-(-1)]", NULL,                               "inc %1", NULL,     /* 04-12-18 */
    "lea %1,[%1+%2]", NULL,                                 "add %1,%2", NULL,
    "lea %1,[%2+%1]", NULL,                                 "add %1,%2", NULL,
    "lea %1,[%1*2]", NULL,                                  "add %1,%1", NULL,  /* shorter; same speed */
    "lea %1,[%2*2]", NULL,                                  "lea %1,[%2+%2]", NULL,  /* shorter; same speed */
    "lea %1,[%1*4]", NULL,                                  "add %1,%1", "add %1,%1", NULL,  /* shorter; 05-01-04 */
    "lea %1,[%1+(#2)]", NULL,                               "add %1,#2", NULL,    /* 04-12-18 */
    "lea %1,[%1-(#2)]", NULL,                               "sub %1,#2", NULL,    /* 04-12-18 */
    "lea %1,[($2)]", NULL,                                  "mov %1,($2)", NULL,  /* 04-12-18 */
    /* added 03-09-06 */
    "lea %1,[%2+(4)]", "mov %2,%1", "mov %1,dword [%1+(-4)]", NULL,  "lea %2,[%2+(4)]", "mov %1,dword [%2+(-4)]", NULL,
    /* added 01-12-22 (more general cases) */
    "mov %1,%2", "mov %2,%1", NULL,                         "mov %1,%2", NULL,
    "mov $1,%2", "mov %2,$1", NULL,                         "mov $1,%2", NULL,
    "mov %1,$2", "mov $2,%1", NULL,                         "mov %1,$2", NULL,
    "and %1,00H", "cmp %1,00H", "jne near $2", NULL,        "xor %1,%1", NULL,  /* 04-10-15 */
    "mov %1,0", NULL,                                       "xor %1,%1", NULL,
    "mov %1,00H", NULL,                                     "xor %1,%1", NULL,  /* 04-07-07 */
    "cmp %1,0", NULL,                                       "test %1,%1", NULL,
    "cmp %1,00H", NULL,                                     "test %1,%1", NULL,  /* 04-07-07 */
    "sub %1,1", NULL,                                       "dec %1", NULL,
    "add %1,1", NULL,                                       "inc %1", NULL,
    "mov $1,-1", NULL,                                      "or $1,-1", NULL,
    "mov $1,0ffffffffH", NULL,                              "or $1,-1", NULL,  /* 03-09-22 */
    "mov %1,%1", NULL,                                      NULL,
    "and %1,0ffffffffH", NULL,                              NULL,               /* 04-07-09 */
    "and %1,00H", NULL,                                     "xor %1,%1", NULL,  /* 04-07-09 */
    "push 0ffffffffH", NULL,                                "push -1", NULL,    /* 04-07-09 */
    "add %1,0ffffffffH", NULL,                              "add %1,-1", NULL,  /* 04-07-09 */
    "call $1", "add esp,(4+3)&(~3)", NULL,                  "call $1", "pop ecx", NULL,
    "jg near $1", "jmp near $2", "$1:", NULL,               "jle near $2", "$1:", NULL,
    "jge near $1", "jmp near $2", "$1:", NULL,              "jl near $2", "$1:", NULL,
    "jl near $1", "jmp near $2", "$1:", NULL,               "jge near $2", "$1:", NULL,
    "jle near $1", "jmp near $2", "$1:", NULL,              "jg near $2", "$1:", NULL,
    "je near $1", "jmp near $2", "$1:", NULL,               "jne near $2", "$1:", NULL,
    "jne near $1", "jmp near $2", "$1:", NULL,              "je near $2", "$1:", NULL,
    "ja near $1", "jmp near $2", "$1:", NULL,               "jbe near $2", "$1:", NULL,
    "jae near $1", "jmp near $2", "$1:", NULL,              "jb near $2", "$1:", NULL,
    "jb near $1", "jmp near $2", "$1:", NULL,               "jae near $2", "$1:", NULL,
    "jbe near $1", "jmp near $2", "$1:", NULL,              "ja near $2", "$1:", NULL,
    "and %1,$2", "and %1,$2", NULL,                         "and %1,$2", NULL,
    "and %1,$2", "cmp %1,0", NULL,                          "and %1,$2", NULL,
    "and %1,$2", "cmp %1,00H", NULL,                        "and %1,$2", NULL,  /* 04-10-15 */
    "or %1,$2", "cmp %1,0", NULL,                           "or %1,$2", NULL,  /* 04-12-17 */
    "or %1,$2", "cmp %1,00H", NULL,                         "or %1,$2", NULL,  /* 04-12-17 */
    "mov %1,$2", "mov $3,%1", "mov %1,$2", "mov $4,%1", NULL,  "mov %1,$2", "mov $3,%1", "mov $4,%1", NULL,
    "lea %1,$2", "mov $3,%1", "lea %1,$2", "mov $4,%1", NULL,  "lea %1,$2", "mov $3,%1", "mov $4,%1", NULL,
    "fstp dword [$1]", "fld dword [$1]", NULL,              "fst dword [$1]", NULL,  /* 03-02-02 */
    "fstp qword [$1]", "fld qword [$1]", NULL,              "fst qword [$1]", NULL,  /* 03-02-02 */
    "mov [$1],%3", "mov [$2],%4", "mov %3,[$1]", "mov %4,[$2]", NULL,  "mov [$1],%3", "mov [$2],%4", NULL,  /* 04-07-09 */
    "mov %1,[$3]", "mov %2,[$4]", "mov [$3],%1", "mov [$4],%2", NULL,  "mov %1,[$3]", "mov %2,[$4]", NULL,  /* 04-07-09 */
    /* added 01-02-18 (mostly for switch statements) */
    "cmp %1,$2", "jg near $3", "cmp %1,$2", NULL,           "cmp %1,$2", "jg near $3", NULL,
    "cmp %1,$2", "jge near $3", "cmp %1,$2", NULL,          "cmp %1,$2", "jge near $3", NULL,
    "cmp %1,$2", "jl near $3", "cmp %1,$2", NULL,           "cmp %1,$2", "jl near $3", NULL,
    "cmp %1,$2", "jle near $3", "cmp %1,$2", NULL,          "cmp %1,$2", "jle near $3", NULL,
    "cmp %1,$2", "je near $3", "cmp %1,$2", NULL,           "cmp %1,$2", "je near $3", NULL,
    "cmp %1,$2", "jne near $3", "cmp %1,$2", NULL,          "cmp %1,$2", "jne near $3", NULL,
    "cmp %1,$2", "ja near $3", "cmp %1,$2", NULL,           "cmp %1,$2", "ja near $3", NULL,
    "cmp %1,$2", "jae near $3", "cmp %1,$2", NULL,          "cmp %1,$2", "jae near $3", NULL,
    "cmp %1,$2", "jb near $3", "cmp %1,$2", NULL,           "cmp %1,$2", "jb near $3", NULL,
    "cmp %1,$2", "jbe near $3", "cmp %1,$2", NULL,          "cmp %1,$2", "jbe near $3", NULL,
    /* added 02-01-10; MAKEWORD() + conversions */
    "and eax,255", "movzx eax,al", NULL,                    "and eax,255", NULL,  /* 04-03-17: movzx -> and: should be faster */
    "and ebx,255", "movzx ebx,bl", NULL,                    "and ebx,255", NULL,  /* 04-03-17: movzx -> and: should be faster */
    "and ecx,255", "movzx ecx,cl", NULL,                    "and ecx,255", NULL,  /* 04-03-17: movzx -> and: should be faster */
    "and edx,255", "movzx edx,dl", NULL,                    "and edx,255", NULL,  /* 04-03-17: movzx -> and: should be faster */
    "movzx eax,al", "movzx eax,ax", NULL,                   "movzx eax,al", NULL,
    "movzx ebx,bl", "movzx ebx,bx", NULL,                   "movzx ebx,bl", NULL,
    "movzx ecx,cl", "movzx ecx,cx", NULL,                   "movzx ecx,cl", NULL,
    "movzx edx,dl", "movzx edx,dx", NULL,                   "movzx edx,dl", NULL,
    "movsx %1,%2", "movzx %1,%2", NULL,                     "movzx %1,%2", NULL,
    "movzx %1,%2", "movsx %1,%2", NULL,                     "movsx %1,%2", NULL,
    /* added 04-10-29 */
    "and eax,65535", "movzx eax,ax", NULL,                 "and eax,65535", NULL,
    "and ebx,65535", "movzx ebx,bx", NULL,                 "and ebx,65535", NULL,
    "and ecx,65535", "movzx ecx,cx", NULL,                 "and ecx,65535", NULL,
    "and edx,65535", "movzx edx,dx", NULL,                 "and edx,65535", NULL,
    /* added 04-03-16 */
    "and eax,0ffffH", "movzx eax,ax", NULL,                 "and eax,0ffffH", NULL,
    "and ebx,0ffffH", "movzx ebx,bx", NULL,                 "and ebx,0ffffH", NULL,
    "and ecx,0ffffH", "movzx ecx,cx", NULL,                 "and ecx,0ffffH", NULL,
    "and edx,0ffffH", "movzx edx,dx", NULL,                 "and edx,0ffffH", NULL,
    /* added 03-09-22 */
    "mov eax,dword [$1]", "movzx eax,al", NULL,             "movzx eax,byte [$1]", NULL,
    "mov ebx,dword [$1]", "movzx ebx,bl", NULL,             "movzx ebx,byte [$1]", NULL,
    "mov ecx,dword [$1]", "movzx ecx,cl", NULL,             "movzx ecx,byte [$1]", NULL,
    "mov edx,dword [$1]", "movzx edx,dl", NULL,             "movzx edx,byte [$1]", NULL,
    "mov eax,dword [$1]", "movzx eax,ax", NULL,             "movzx eax,word [$1]", NULL,
    "mov ebx,dword [$1]", "movzx ebx,bx", NULL,             "movzx ebx,word [$1]", NULL,
    "mov ecx,dword [$1]", "movzx ecx,cx", NULL,             "movzx ecx,word [$1]", NULL,
    "mov edx,dword [$1]", "movzx edx,dx", NULL,             "movzx edx,word [$1]", NULL,
    "mov eax,ebx", "movzx eax,ax", NULL,                    "movzx eax,bx", NULL,
    "mov edx,ebx", "movzx edx,dx", NULL,                    "movzx edx,bx", NULL,
    /* added 01-11-12; if (!fn()) return 0; */
    "test %1,%1", "jne near $2", "mov %1,0", "jmp near $3", "$2:", NULL,  "test %1,%1", "je near $3", "$2:", NULL,
    /* added 01-01-05 (_Bool conversion) */
    "add %1,$2", "cmp %1,0", "setne %3", NULL,              "add %1,$2", "setne %3", NULL,
    "inc %1", "cmp %1,0", "setne %3", NULL,                 "inc %1", "setne %3", NULL,
    "sub %1,$2", "cmp %1,0", "setne %3", NULL,              "sub %1,$2", "setne %3", NULL,
    "dec %1", "cmp %1,0", "setne %3", NULL,                 "dec %1", "setne %3", NULL,
    "and %1,$2", "cmp %1,0", "setne %3", NULL,              "and %1,$2", "setne %3", NULL,
    "or %1,$2", "cmp %1,0", "setne %3", NULL,               "or %1,$2", "setne %3", NULL,
    "xor %1,$2", "cmp %1,0", "setne %3", NULL,              "xor %1,$2", "setne %3", NULL,
    "shl %1,$2", "cmp %1,0", "setne %3", NULL,              "shl %1,$2", "setne %3", NULL,
    "shr %1,$2", "cmp %1,0", "setne %3", NULL,              "shr %1,$2", "setne %3", NULL,
    "sar %1,$2", "cmp %1,0", "setne %3", NULL,              "sar %1,$2", "setne %3", NULL,
    /* added 04-07-22 */
    "add %1,$2", "cmp %1,0", "jne near $3", NULL,           "add %1,$2", "jne near $3", NULL,
    "add %1,$2", "cmp %1,0", "je near $3", NULL,            "add %1,$2", "je near $3", NULL,
    "sub %1,$2", "cmp %1,0", "jne near $3", NULL,           "sub %1,$2", "jne near $3", NULL,  /* bugfix 04-10-29: add->sub */
    "sub %1,$2", "cmp %1,0", "je near $3", NULL,            "sub %1,$2", "je near $3", NULL,   /* bugfix 04-10-29: add->sub */
    /* added 02-05-07 (general observation) */
    "mov %1,$2", "cmp %1,$3", "je $4", "mov %1,$2", NULL,   "mov %1,$2", "cmp %1,$3", "je $4", NULL,
    "mov %1,$2", "cmp %1,$3", "jne $4", "mov %1,$2", NULL,  "mov %1,$2", "cmp %1,$3", "jne $4", NULL,
    /* added 04-12-18 (ditto) */
    "mov %1,$2", "mov %3,%1", "mov %1,$4", NULL,            "mov %3,$2", "mov %1,$4", NULL,
    /* floating-point calcs */
    "add esp,4", "sub esp,4", NULL,                         NULL,
    "add esp,8", "sub esp,8", NULL,                         NULL,
    "add esp,4", "sub esp,8", NULL,                         "sub esp,4", NULL,
    /* added 04-03-16 (clean up after dead code elimination) */
    "jmp near $1", "$1:", NULL,                             "$1:", NULL,
    /* added 04-04-01 (clean up leaf functions) */
    "ret", "ret", NULL,                                     "ret", NULL,
    "ret $1", "ret $2", NULL,                               "ret $1", NULL,
    "ret", "jmp $1", NULL,                                  "ret", NULL,
    "ret $1", "jmp $2", NULL,                               "ret $1", NULL,
    "ret", "$1:", "ret", NULL,                              "$1:", "ret", NULL,
    "ret $1", "$2:", "ret $3", NULL,                        "$2:", "ret $3", NULL,
    /* speed up(?) multiplications (2,4,8 is handled elsewhere, 7 is impossible) */
    "imul %1,%2,3", NULL,                                   "lea %1,[%2*2+%2]", NULL,
    "imul %1,$2,3", NULL,                                   "mov %1,$2", "lea %1,[%1*2+%1]", NULL,
    "imul %1,%2,5", NULL,                                   "lea %1,[%2*4+%2]", NULL,
    "imul %1,$2,5", NULL,                                   "mov %1,$2", "lea %1,[%1*4+%1]", NULL,
    "imul %1,%2,6", NULL,                                   "lea %1,[%2*2+%2]", "add %1,%1", NULL,
    "imul %1,$2,6", NULL,                                   "mov %1,$2", "lea %1,[%1*2+%1]", "add %1,%1", NULL,
    "imul %1,%2,9", NULL,                                   "lea %1,[%2*8+%2]", NULL,
    "imul %1,$2,9", NULL,                                   "mov %1,$2", "lea %1,[%1*8+%1]", NULL,
    "imul %1,%2,10", NULL,                                  "lea %1,[%2*4+%2]", "add %1,%1", NULL,
    "imul %1,$2,10", NULL,                                  "mov %1,$2", "lea %1,[%1*4+%1]", "add %1,%1", NULL,
    "imul %1,3", NULL,                                      "lea %1,[%1*2+%1]", NULL,
    "imul %1,5", NULL,                                      "lea %1,[%1*4+%1]", NULL,
    "imul %1,6", NULL,                                      "lea %1,[%1*2+%1]", "add %1,%1", NULL,
    "imul %1,9", NULL,                                      "lea %1,[%1*8+%1]", NULL,
    "imul %1,10", NULL,                                     "lea %1,[%1*4+%1]", "add %1,%1", NULL,
    /* added 04-08-06 */
    "cmp %1,$2", "jne near $3", "mov %1,$2", "jmp near $4", "$3:", NULL, "cmp %1,$2", "je near $4", "$3:", NULL,
    /* added 04-12-28 */
    "sub esp,#1", "sub esp,#2", NULL,                       "sub esp,(#1)+(#2)", NULL,
    NULL
};

/*
 * Minimize space rules.
 */
static const char *minspace_rules[] = {
    "mov dword [$1],00H", NULL,             "and dword [$1],0", NULL,  /* 04-07-09 */
    "mov dword [$1],0", NULL,               "and dword [$1],0", NULL,  /* 04-07-09 */
    "sub esp,4", NULL,                      "push dword eax", NULL,    /* 04-11-25 */
    "mov %1,1", NULL,                       "xor %1,%1", "inc %1", NULL,  /* 04-11-25 */
    "lea %1,[%1*4]", NULL,                  "shl %1,2", NULL,  /* 04-12-02 */
    "lea %1,[%2*4]", NULL,                  "mov %1,%2", "shl %1,2", NULL,  /* 04-12-02 */
    "lea %1,[%1*8]", NULL,                  "shl %1,3", NULL,  /* 04-12-02 */
    "lea %1,[%2*8]", NULL,                  "mov %1,%2", "shl %1,3", NULL,  /* 04-12-02 */
    "call $1", "add esp,(8+3)&(~3)", NULL,  "call $1", "pop ecx", "pop ecx", NULL,  /* 04-11-25 */
    NULL
};

/*
 * Pentium II rules (maximum optimization).
 */
static const char *ppro_rules[] = {
    /* added 01-04-07 (Pentium II and above; only r/m allowed for 2nd argument) */
    "jg near $1", "mov %2,%3", "$1:", NULL,                 "cmovle %2,%3", "$1:", NULL,
    "jge near $1", "mov %2,%3", "$1:", NULL,                "cmovl %2,%3", "$1:", NULL,
    "jl near $1", "mov %2,%3", "$1:", NULL,                 "cmovge %2,%3", "$1:", NULL,
    "jle near $1", "mov %2,%3", "$1:", NULL,                "cmovg %2,%3", "$1:", NULL,
    "je near $1", "mov %2,%3", "$1:", NULL,                 "cmovne %2,%3", "$1:", NULL,
    "jne near $1", "mov %2,%3", "$1:", NULL,                "cmove %2,%3", "$1:", NULL,
    "ja near $1", "mov %2,%3", "$1:", NULL,                 "cmovbe %2,%3", "$1:", NULL,
    "jae near $1", "mov %2,%3", "$1:", NULL,                "cmovb %2,%3", "$1:", NULL,
    "jb near $1", "mov %2,%3", "$1:", NULL,                 "cmovae %2,%3", "$1:", NULL,
    "jbe near $1", "mov %2,%3", "$1:", NULL,                "cmova %2,%3", "$1:", NULL,
    "jg near $1", "mov %2,dword [$3]", "$1:", NULL,         "cmovle %2,dword [$3]", "$1:", NULL,
    "jge near $1", "mov %2,dword [$3]", "$1:", NULL,        "cmovl %2,dword [$3]", "$1:", NULL,
    "jl near $1", "mov %2,dword [$3]", "$1:", NULL,         "cmovge %2,dword [$3]", "$1:", NULL,
    "jle near $1", "mov %2,dword [$3]", "$1:", NULL,        "cmovg %2,dword [$3]", "$1:", NULL,
    "je near $1", "mov %2,dword [$3]", "$1:", NULL,         "cmovne %2,dword [$3]", "$1:", NULL,
    "jne near $1", "mov %2,dword [$3]", "$1:", NULL,        "cmove %2,dword [$3]", "$1:", NULL,
    "ja near $1", "mov %2,dword [$3]", "$1:", NULL,         "cmovbe %2,dword [$3]", "$1:", NULL,
    "jae near $1", "mov %2,dword [$3]", "$1:", NULL,        "cmovb %2,dword [$3]", "$1:", NULL,
    "jb near $1", "mov %2,dword [$3]", "$1:", NULL,         "cmovae %2,dword [$3]", "$1:", NULL,
    "jbe near $1", "mov %2,dword [$3]", "$1:", NULL,        "cmova %2,dword [$3]", "$1:", NULL,
    NULL
};

/*
 * Pentium 4 rules (maximum optimization).
 */
static const char *p4_rules[] = {
    "inc %1", NULL,         "add %1,1", NULL,  /* 04-12-12 */
    "dec %1", NULL,         "sub %1,1", NULL,  /* 04-12-12 */
    NULL
};

/*
 * For Pentium 4:
 * "inc", "dec" instructions should be replaced with "add", "sub".
 * replace "shl" with up to three add's.
 * Try to use zero extension instead of moves with sign extension (movs?).
 */

#include "codeview.c"

/****************************************************************************
 *                                                                          *
 * Function: memop                                                          *
 *                                                                          *
 * Purpose : Confirm the tree form: ASGNa(x,b(INDIR(x),c)).                 *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static int memop(NODE *p)
{
    assert(p);
    assert(generic(p->op) == ASGN);
    assert(p->kids[0]);
    assert(p->kids[1]);

    if (generic(p->kids[1]->kids[0]->op) == INDIR &&
        sametree(p->kids[0], p->kids[1]->kids[0]->kids[0]))
        return 3;
    else
        return LBURG_MAX;
}

/****************************************************************************
 *                                                                          *
 * Function: memop2                                                         *
 *                                                                          *
 * Purpose : Confirm the tree form: ASGNa(x,b(c(d(INDIR(x)),e))).           *
 *                                                                          *
 * History : Date      Reason                                               *
 *           04-03-19  Created                                              *
 *                                                                          *
 ****************************************************************************/

static int memop2(NODE *p)
{
    assert(p);
    assert(generic(p->op) == ASGN);
    assert(p->kids[0]);
    assert(p->kids[1]);

    if (generic(p->kids[1]->kids[0]->kids[0]->kids[0]->op) == INDIR &&
        sametree(p->kids[0], p->kids[1]->kids[0]->kids[0]->kids[0]->kids[0]))
        return 3;
    else
        return LBURG_MAX;
}

/****************************************************************************
 *                                                                          *
 * Function: memop3                                                         *
 *                                                                          *
 * Purpose : Confirm the tree form: ASGNa(x,b(c(d(e(INDIR(x)),f)))).        *
 *                                                                          *
 * History : Date      Reason                                               *
 *           04-03-19  Created                                              *
 *                                                                          *
 ****************************************************************************/

static int memop3(NODE *p)
{
    assert(p);
    assert(generic(p->op) == ASGN);
    assert(p->kids[0]);
    assert(p->kids[1]);

    if (generic(p->kids[1]->kids[0]->kids[0]->kids[0]->kids[0]->op) == INDIR &&
        sametree(p->kids[0], p->kids[1]->kids[0]->kids[0]->kids[0]->kids[0]->kids[0]))
        return 3;
    else
        return LBURG_MAX;
}

/****************************************************************************
 *                                                                          *
 * Function: sametree                                                       *
 *                                                                          *
 * Purpose : Confirm that destination is same as the first source operand.  *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static int sametree(NODE *p, NODE *q)
{
    return p == NULL && q == NULL ||
        p && q && p->op == q->op && p->syms[0] == q->syms[0] &&
        sametree(p->kids[0], q->kids[0]) &&
        sametree(p->kids[1], q->kids[1]);
}

/****************************************************************************
 *                                                                          *
 * Function: popargs                                                        *
 *                                                                          *
 * Purpose : Return the cost of a CDECL call (caller pops).                 *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *           00-10-17  Support for CRT function _alloca() added.            *
 *                                                                          *
 ****************************************************************************/

static int popargs(NODE *p)
{
    assert(p);
    assert(generic(p->op) == CALL);
    assert(p->syms[0]);
    assert(p->syms[1]);
    assert(isfunc(p->syms[1]->type));

    /* special handling of the _alloca() function */
    if (p->kids[0] && p->kids[0]->syms[0] && strcmp(
        p->kids[0]->syms[0]->name, "_alloca") == 0 && p->syms[0]->u.c.v.i == 4)
        return LBURG_MAX;

    /* cdecl function with arguments? */
    if (iscdecl(p->syms[1]->type))
        return (p->syms[0]->u.c.v.i > 0) ? 0 : LBURG_MAX;
    else
        return LBURG_MAX;
}

/****************************************************************************
 *                                                                          *
 * Function: XINTERFACE::regmap                                             *
 *                                                                          *
 * Purpose : Map a data type to a register set.                             *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static SYMBOL *regmap(int op)
{
    switch (optype(op))
    {
        case B:
        case P:
            return intregw;

        case I:
        case U:
            switch (opsize(op))
            {
                case 1: return charregw;
                case 2: return shortregw;
                case 4: return intregw;
                case 8: return longregw;
                default: assert(0);
            }

        case F:
            return fltregw;

        default:
            return NULL;
    }
}

/****************************************************************************
 *                                                                          *
 * Function: XINTERFACE::target                                             *
 *                                                                          *
 * Purpose : Set target register for an operation.                          *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *           03-09-19  Rewritten.                                           *
 *           04-03-08  Added operators CEQ, CGE, CGT, CLE, CLT, CNE.        *
 *           04-07-02  Support for fastcall arguments added.                *
 *           04-07-15  Added operators INTRIN1{S}, INTRIN2{S}.              *
 *           04-11-20  Added INTRIN_CPUID.                                  *
 *           04-12-09  Added INTRIN_WCSLEN, INTRIN_WCSCPY.                  *
 *           04-12-18  Bugfix: modified MULU4, DIVI4, DIVU4, MODI4, MODU4.  *
 *           05-01-05  Avoid immediate spill of ASGN store address.         *
 *                                                                          *
 ****************************************************************************/

static void target(NODE *p)
{
    assert(p);

    switch (p->op)
    {
        case CEQ+I+sizeop(4):
        case CGE+I+sizeop(4):
        case CGT+I+sizeop(4):
        case CLE+I+sizeop(4):
        case CLT+I+sizeop(4):
        case CNE+I+sizeop(4):
        case CEQ+U+sizeop(4):
        case CGE+U+sizeop(4):
        case CGT+U+sizeop(4):
        case CLE+U+sizeop(4):
        case CLT+U+sizeop(4):
        case CNE+U+sizeop(4):
            set_register(p, intreg[EAX]);
            break;

        case LSH+I+sizeop(8):
        case LSH+U+sizeop(8):
        case RSH+I+sizeop(8):
        case RSH+U+sizeop(8):
        case MUL+I+sizeop(8):
        case MUL+U+sizeop(8):
        case DIV+I+sizeop(8):
        case DIV+U+sizeop(8):
        case MOD+I+sizeop(8):
        case MOD+U+sizeop(8):
        case CVF+I+sizeop(8):
        case CALL+I+sizeop(8):
        case CALL+U+sizeop(8):
            set_register(p, longreg[EAX]);
            break;

        case RET+I+sizeop(8):
        case RET+U+sizeop(8):
            target_register(p, 0, longreg[EAX]);
            break;

        case LSH+I+sizeop(4):
        case LSH+U+sizeop(4):
        case RSH+I+sizeop(4):
        case RSH+U+sizeop(4):
            if (generic(p->kids[1]->op) != CNST && !(generic(p->kids[1]->op) == INDIR &&
                specific(p->kids[1]->kids[0]->op) == VREG+P && p->kids[1]->syms[RX]->u.t.cse &&
                generic(p->kids[1]->syms[RX]->u.t.cse->op) == CNST))
            {
                target_register(p, 1, intreg[ECX]);
            }
            break;

        case MUL+U+sizeop(4):
            target_register(p, 0, intreg[EAX]);
            set_register(p, intreg[EAX]);
            break;

        case DIV+I+sizeop(4):
        case DIV+U+sizeop(4):
            set_register(p, intreg[EAX]);
            target_register(p, 0, intreg[EAX]);
            if (options.pragmaopt != MAXSPEED ||
                (generic(p->kids[1]->op) != CNST && !(generic(p->kids[1]->op) == INDIR &&
                specific(p->kids[1]->kids[0]->op) == VREG+P && p->kids[1]->syms[RX]->u.t.cse &&
                generic(p->kids[1]->syms[RX]->u.t.cse->op) == CNST)))
            {
                target_register(p, 1, intreg[ECX]);
            }
            break;

        case MOD+I+sizeop(4):
        case MOD+U+sizeop(4):
            target_register(p, 0, intreg[EAX]);
            target_register(p, 1, intreg[ECX]);
            set_register(p, intreg[EDX]);
            break;

        case CVF+I+sizeop(4):
            set_register(p, intreg[EAX]);
            break;

        case CALL+I+sizeop(4):
        case CALL+U+sizeop(4):
        case CALL+P+sizeop(4):
            set_register(p, intreg[EAX]);
            break;

        case RET+I+sizeop(4):
        case RET+U+sizeop(4):
        case RET+P+sizeop(4):
            target_register(p, 0, intreg[EAX]);
            break;

        case ASGN+I+sizeop(1):
        case ASGN+I+sizeop(2):
        case ASGN+I+sizeop(4):
        case ASGN+U+sizeop(1):
        case ASGN+U+sizeop(2):
        case ASGN+U+sizeop(4):
        case ASGN+P+sizeop(4):
            /* avoid immediate spill of the store address (05-01-04) */
            if (specific(p->kids[0]->op) == INDIR+P && p->kids[0]->kids[0]->op != VREG+P)
                target_register(p, 0, intreg[EDX]);
            else if (specific(p->kids[0]->op) == ADD+P && specific(p->kids[0]->kids[0]->op) == INDIR+P && p->kids[0]->kids[0]->kids[0]->op != VREG+P)
                target_register(p->kids[0], 0, intreg[EDX]);
            break;

        case ASGN+B:
            target_register(p, 0, intreg[EDI]);
            target_register(p->kids[1], 0, intreg[ESI]);
            break;

        case ARG+B:
            target_register(p->kids[0], 0, intreg[ESI]);
            break;

        case ARG+I+sizeop(4):
        case ARG+U+sizeop(4):
        case ARG+P+sizeop(4):
        {
            /* argno above zero is a fastcall argument */
            SYMBOL *rsym = argreg(p->x.argno, opsize(p->op));
            if (rsym != NULL)
            {
                target_register(p, 0, rsym);
                p->op = LOAD + opkind(p->op);  /* see book */
                set_register(p, rsym);
            }
            break;
        }

        case INTRIN1+I+sizeop(4):
        case INTRIN1+U+sizeop(4):
        case INTRIN1+P+sizeop(4):
        case INTRIN1S+I+sizeop(4):
        case INTRIN1S+U+sizeop(2):
        case INTRIN1S+U+sizeop(4):
        case INTRIN1S+P+sizeop(4):
        case INTRIN2+I+sizeop(4):
        case INTRIN2+U+sizeop(4):
        case INTRIN2+P+sizeop(4):
        case INTRIN2S+I+sizeop(4):
        case INTRIN2S+U+sizeop(2):
        case INTRIN2S+U+sizeop(4):
        case INTRIN2S+P+sizeop(4):
            /* handle compiler intrinsic functions */
            switch((int)p->syms[0]->u.c.v.i)
            {
                case INTRIN_STRLEN:
                case INTRIN_WCSLEN:
                    target_register(p, 0, intreg[EDX]);
                    break;

                case INTRIN_STRCPY:
                case INTRIN_WCSCPY:
                    target_register(p, 0, intreg[ECX]);
                    target_register(p, 1, intreg[EDX]);
                    break;

                case INTRIN_STRCMP:
                    target_register(p, 0, intreg[ECX]);
                    target_register(p, 1, intreg[EDX]);
                    break;

                case INTRIN_MEMSET:
                    target_register(p, 0, intreg[EDX]);
                    target_register(p, 1, intreg[ECX]);
                    break;

                case INTRIN_ROTL:
                case INTRIN_ROTR:
                case INTRIN_LROTL:
                case INTRIN_LROTR:
                    target_register(p, 0, intreg[EAX]);
                    target_register(p, 1, intreg[ECX]);
                    break;

                case INTRIN_INP:
                case INTRIN_INPD:
                case INTRIN_INPW:
                    target_register(p, 0, intreg[EDX]);
                    break;

                case INTRIN_OUTP:
                case INTRIN_OUTPD:
                case INTRIN_OUTPW:
                    target_register(p, 0, intreg[EDX]);
                    target_register(p, 1, intreg[EAX]);
                    break;

                case INTRIN_BSWAP:
                    target_register(p, 0, intreg[EAX]);
                    break;

                case INTRIN_ABS:
                case INTRIN_LABS:
                    target_register(p, 0, intreg[EAX]);
                    break;

                default:
                    assert(0);
            }
            set_register(p, intreg[EAX]);
            break;

        case INTRIN1S+U+sizeop(8):
            assert((int)p->syms[0]->u.c.v.i == INTRIN_RDTSC);
            set_register(p, longreg[EAX]);
            break;

        case INTRIN2S+V:
            assert((int)p->syms[0]->u.c.v.i == INTRIN_CPUID);
            target_register(p, 0, intreg[EDX]);
            target_register(p, 1, intreg[EAX]);
            break;
    }
}

/****************************************************************************
 *                                                                          *
 * Function: XINTERFACE::clobber                                            *
 *                                                                          *
 * Purpose : Spill and reload busy registers.                               *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *           03-09-19  Rewritten.                                           *
 *           03-11-17  Bugfix: CVFI4() uses __ftoll() which clobbers EDX!   *
 *           04-07-15  Added operators INTRIN1{S}, INTRIN2{S}.              *
 *           04-10-30  Bugfix: ASGN+B for 4 byte struct was buggy.          *
 *           04-11-20  Added INTRIN_CPUID.                                  *
 *           04-12-09  Added INTRIN_WCSCPY.                                 *
 *           04-12-18  Added MULU4, DIVI4, DIVU4, MODI4, MODU4.             *
 *                                                                          *
 ****************************************************************************/

static void clobber(NODE *p)
{
    static int nstack = 0;

    assert(p);
    nstack = fpstack(p, nstack);

    switch (p->op)
    {
        case LSH+I+sizeop(8):
        case LSH+U+sizeop(8):
        case RSH+I+sizeop(8):
        case RSH+U+sizeop(8):
        case MUL+I+sizeop(8):
        case MUL+U+sizeop(8):
        case DIV+I+sizeop(8):
        case DIV+U+sizeop(8):
        case MOD+I+sizeop(8):
        case MOD+U+sizeop(8):
        case CALL+I+sizeop(8):
        case CALL+U+sizeop(8):
            spill(1<<ECX, IREG, p);
            break;

        case MUL+U+sizeop(4):
        case DIV+I+sizeop(4):
        case DIV+U+sizeop(4):
            spill(1<<EDX, IREG, p);
            break;

        case MOD+I+sizeop(4):
        case MOD+U+sizeop(4):
            spill(1<<EAX, IREG, p);
            break;

        case LSH+I+sizeop(4):
        case LSH+U+sizeop(4):
        case RSH+I+sizeop(4):
        case RSH+U+sizeop(4):
            if (generic(p->kids[1]->op) != CNST && !(generic(p->kids[1]->op) == INDIR &&
                specific(p->kids[1]->kids[0]->op) == VREG+P && p->kids[1]->syms[RX]->u.t.cse &&
                generic(p->kids[1]->syms[RX]->u.t.cse->op) == CNST))
            {
                spill(1<<ECX, IREG, p);
            }
            break;

        case CVF+I+sizeop(4):
            if (options.microsoft)
                spill(1<<EDX, IREG, p);
            break;

        case CALL+I+sizeop(4):
        case CALL+U+sizeop(4):
        case CALL+P+sizeop(4):
            spill(1<<EDX|1<<ECX, IREG, p);
            break;

        case CALL+F+sizeop(8):
        case CALL+F+sizeop(4):
        case CALL+V:
            spill(1<<EDX|1<<EAX|1<<ECX, IREG, p);
            break;

        case EQ+F+sizeop(8):
        case LE+F+sizeop(8):
        case GE+F+sizeop(8):
        case LT+F+sizeop(8):
        case GT+F+sizeop(8):
        case NE+F+sizeop(8):
        case EQ+F+sizeop(4):
        case LE+F+sizeop(4):
        case GE+F+sizeop(4):
        case LT+F+sizeop(4):
        case GT+F+sizeop(4):
        case NE+F+sizeop(4):
            spill(1<<EAX, IREG, p);
            break;

        case ASGN+B:
            spill(1<<ECX|1<<ESI|1<<EDI, IREG, p);
            break;

        case ARG+B:
            spill(1<<ECX|1<<ESI|1<<EDI, IREG, p);
            break;

        case INTRIN1+I+sizeop(4):
        case INTRIN1+U+sizeop(4):
        case INTRIN1+P+sizeop(4):
        case INTRIN1S+I+sizeop(4):
        case INTRIN1S+U+sizeop(2):  /* _inpw() */
        case INTRIN1S+U+sizeop(4):
        case INTRIN1S+P+sizeop(4):
        case INTRIN2+I+sizeop(4):
        case INTRIN2+U+sizeop(4):
        case INTRIN2+P+sizeop(4):
        case INTRIN2S+I+sizeop(4):
        case INTRIN2S+U+sizeop(2):  /* _outpw() */
        case INTRIN2S+U+sizeop(4):
        case INTRIN2S+P+sizeop(4):
        case INTRIN2S+V:            /* _cpuid() */
            /* handle compiler intrinsic functions */
            switch((int)p->syms[0]->u.c.v.i)
            {
                case INTRIN_STRCPY:
                case INTRIN_WCSCPY:
                case INTRIN_STRCMP:
                    spill(1<<ECX|1<<EDX, IREG, p);
                    break;

                case INTRIN_MEMSET:
                    spill(1<<ECX, IREG, p);
                    break;

                case INTRIN_ABS:
                case INTRIN_LABS:
                    spill(1<<EDX, IREG, p);
                    break;

                case INTRIN_CPUID:
                    spill(1<<EAX|1<<ECX|1<<EDX, IREG, p);
                    break;
            }
            break;
    }
}

/****************************************************************************
 *                                                                          *
 * Function: fpstack                                                        *
 *                                                                          *
 * Purpose : Check the floating-point stack.                                *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

#define isfp(p) (optype((p)->op)==F)
static int fpstack(NODE *p, int n)
{
    int i;

    for (i = 0; i < NELEMS(p->x.kids) && p->x.kids[i]; i++)
        if (isfp(p->x.kids[i])) n--;

    if (isfp(p) && p->count > 0)
        n++;

    if (n > 8)  /* max 8 entries on FPU stack */
        apperror(RCERROR(ERROR_FP_EXPRESSION_TOO_COMPLEX));

    debug(fprint(stdout, NULL, "(fpstack(%x)=%d)\n", p, n));
    assert(n >= 0);
    return n;
}

/****************************************************************************
 *                                                                          *
 * Function: XINTERFACE::doarg                                              *
 *                                                                          *
 * Purpose : Define a new argument to a function.                           *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void doarg(NODE *p)
{
    assert(p && p->syms[0]);
    mkparm(4 /*align*/, (int)p->syms[0]->u.c.v.i /*size*/);
}

/****************************************************************************
 *                                                                          *
 * Function: XINTERFACE::emit2                                              *
 *                                                                          *
 * Purpose : Escape hatch to generate machine specific code.                *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *           03-09-19  Rewritten.                                           *
 *           04-03-03  Handle arguments in leaf functions (esp+n).          *
 *           04-04-01  Handle return from leaf functions.                   *
 *           04-07-02  Handle arguments to fastcall functions.              *
 *           04-07-09  Support for long long integers rewritten.            *
 *           04-07-15  Added operators INTRIN1{S}, INTRIN2{S}.              *
 *           04-08-20  Added INTRIN_RDTSC and INTRIN_BSWAP.                 *
 *           04-09-01  Bugfix: rdtsc requires pentium, but default is 486.  *
 *           04-11-20  Added INTRIN_CPUID.                                  *
 *           04-12-09  Added INTRIN_WCSLEN, INTRIN_WCSCPY.                  *
 *           04-12-18  Added operators DIVI4, DIVU4 (fast division).        *
 *           04-12-27  CBOOL operator will now handle long long's.          *
 *                                                                          *
 ****************************************************************************/

#define LO_DWORD(n)  ((n) & 0xFFFFFFFF)
#define HI_DWORD(n)  ((n) >> 32 & 0xFFFFFFFF)
static void emit2(NODE *p)
{
    switch (p->op)
    {
        case INTRIN1+I+sizeop(4):
        case INTRIN1+U+sizeop(4):
        case INTRIN1+P+sizeop(4):
        case INTRIN1+F+sizeop(4):
        case INTRIN1+F+sizeop(8):
        case INTRIN1S+I+sizeop(4):
        case INTRIN1S+U+sizeop(2):
        case INTRIN1S+U+sizeop(4):
        case INTRIN1S+P+sizeop(4):
        case INTRIN1S+U+sizeop(8):
        case INTRIN1S+V:
        case INTRIN2+I+sizeop(4):
        case INTRIN2+U+sizeop(4):
        case INTRIN2+P+sizeop(4):
        case INTRIN2+F+sizeop(4):
        case INTRIN2+F+sizeop(8):
        case INTRIN2S+I+sizeop(4):
        case INTRIN2S+U+sizeop(2):
        case INTRIN2S+U+sizeop(4):
        case INTRIN2S+P+sizeop(4):
        case INTRIN2S+V:
        {
            /* handle compiler intrinsic functions */
            switch ((int)p->syms[0]->u.c.v.i)
            {
                case INTRIN_STRLEN:
                {
                    int src = register_number(p->x.kids[0]);
                    int lab = make_label(1);
                    assert(src != EAX);
                    print("mov eax,-1\n");
                    print("@%d:\n", lab);
                    print("add eax,1\n");
                    print("cmp byte [%s+eax],0\n", intreg[src]->x.name);
                    print("jne @%d\n", lab);
                    break;
                }
                case INTRIN_WCSLEN:
                {
                    int src = register_number(p->x.kids[0]);
                    int lab = make_label(1);
                    assert(src != EAX);
                    print("mov eax,-2\n");
                    print("@%d:\n", lab);
                    print("add eax,2\n");
                    print("cmp word [%s+eax],0\n", intreg[src]->x.name);
                    print("jne @%d\n", lab);
                    print("shr eax,1\n");  /* we have length*2 - adjust */
                    break;
                }
                case INTRIN_STRCPY:
                {
                    int op1 = register_number(p->x.kids[0]);
                    int op2 = register_number(p->x.kids[1]);
                    int lab = make_label(1);
                    print("push dword %s\n", intreg[op1]->x.name);
                    print("sub %s,%s\n", intreg[op1]->x.name, intreg[op2]->x.name);
                    print("@%d:\n", lab);
                    print("mov al,[%s]\n", intreg[op2]->x.name);
                    print("mov [%s+%s],al\n", intreg[op1]->x.name, intreg[op2]->x.name);
                    print("add %s,1\n", intreg[op2]->x.name);
                    print("cmp al,0\n");
                    print("jne @%d\n", lab);
                    print("pop dword eax\n");
                    break;
                }
                case INTRIN_WCSCPY:
                {
                    int op1 = register_number(p->x.kids[0]);
                    int op2 = register_number(p->x.kids[1]);
                    int lab = make_label(1);
                    print("push dword %s\n", intreg[op1]->x.name);
                    print("sub %s,%s\n", intreg[op1]->x.name, intreg[op2]->x.name);
                    print("@%d:\n", lab);
                    print("mov ax,[%s]\n", intreg[op2]->x.name);
                    print("mov [%s+%s],ax\n", intreg[op1]->x.name, intreg[op2]->x.name);
                    print("add %s,2\n", intreg[op2]->x.name);
                    print("cmp ax,0\n");
                    print("jne @%d\n", lab);
                    print("pop dword eax\n");
                    break;
                }
                case INTRIN_STRCMP:
                {
                    int op1 = register_number(p->x.kids[0]);
                    int op2 = register_number(p->x.kids[1]);
                    int lab = make_label(3);
                    print("mov eax,0\n");
                    print("@%d:\n", lab);
                    print("mov al,byte [%s]\n", intreg[op2]->x.name);
                    print("mov ah,byte [%s]\n", intreg[op1]->x.name);
                    print("sub ah,al\n");
                    print("jne near @%d\n", lab+1);
                    print("test al,al\n");
                    print("je near @%d\n", lab+2);
                    print("add %s,1\n", intreg[op2]->x.name);
                    print("add %s,1\n", intreg[op1]->x.name);
                    print("jmp near @%d\n", lab);
                    print("@%d:\n", lab+1);
                    print("sbb eax,eax\n");
                    print("sbb eax,byte -1\n");
                    print("@%d:\n", lab+2);
                    break;
                }
                case INTRIN_MEMSET:  /* byte */
                {
                    int op1 = register_number(p->x.kids[0]);
                    assert(register_number(p->x.kids[1]) == ECX);
                    print("mov eax,0\n");
                    print("push dword edi\n");
                    print("mov edi,%s\n", intreg[op1]->x.name);
                    print("rep stosb\n");
                    print("pop dword edi\n");
                    print("mov eax,%s\n", intreg[op1]->x.name);
                    break;
                }
                case INTRIN_ROTL:
                case INTRIN_LROTL:
                {
                    assert(register_number(p->x.kids[0]) == EAX);
                    assert(register_number(p->x.kids[1]) == ECX);
                    print("rol eax,cl\n");
                    break;
                }
                case INTRIN_ROTR:
                case INTRIN_LROTR:
                {
                    assert(register_number(p->x.kids[0]) == EAX);
                    assert(register_number(p->x.kids[1]) == ECX);
                    print("ror eax,cl\n");
                    break;
                }
                case INTRIN_INP:
                {
                    assert(register_number(p->x.kids[0]) == EDX);
                    print("xor eax,eax\n");
                    print("in al,dx\n");
                    break;
                }
                case INTRIN_INPD:
                {
                    assert(register_number(p->x.kids[0]) == EDX);
                    print("in eax,dx\n");
                    break;
                }
                case INTRIN_INPW:
                {
                    assert(register_number(p->x.kids[0]) == EDX);
                    print("in ax,dx\n");
                    break;
                }
                case INTRIN_OUTP:
                {
                    assert(register_number(p->x.kids[0]) == EDX);
                    assert(register_number(p->x.kids[1]) == EAX);
                    print("out dx,al\n");
                    break;
                }
                case INTRIN_OUTPD:
                {
                    assert(register_number(p->x.kids[0]) == EDX);
                    assert(register_number(p->x.kids[1]) == EAX);
                    print("out dx,eax\n");
                    break;
                }
                case INTRIN_OUTPW:
                {
                    assert(register_number(p->x.kids[0]) == EDX);
                    assert(register_number(p->x.kids[1]) == EAX);
                    print("out dx,ax\n");
                    break;
                }
                case INTRIN_RDTSC:
                {
                    print(options.maxopt ? "rdtsc\n" : "[cpu pentium]\nrdtsc\n[cpu 486]\n");
                    break;
                }
                case INTRIN_BSWAP:
                {
                    int src = register_number(p->x.kids[0]);
                    print("bswap %s\n", intreg[src]->x.name);
                    break;
                }
                case INTRIN_CPUID:
                {
                    assert(register_number(p->x.kids[0]) == EDX);
                    assert(register_number(p->x.kids[1]) == EAX);
                    print("push ebx\n");
                    print("push edi\n");
                    print("mov edi,edx\n");
                    print(options.maxopt ? "cpuid\n" : "[cpu pentium]\ncpuid\n[cpu 486]\n");
                    print("mov [edi],eax\n");
                    print("mov [edi+4],ebx\n");
                    print("mov [edi+8],ecx\n");
                    print("mov [edi+12],edx\n");
                    print("pop edi\n");
                    print("pop ebx\n");
                    break;
                }
                case INTRIN_ABS:
                case INTRIN_LABS:
                {
                    assert(register_number(p->x.kids[0]) == EAX);
                    print("cdq\n");
                    print("xor eax,edx\n");
                    print("sub eax,edx\n");
                    break;
                }
                case INTRIN_FABS:
                case INTRIN_FABSF:
                {
                    print("fabs\n");
                    break;
                }
                case INTRIN_SQRT:
                case INTRIN_SQRTF:
                {
                    print("fsqrt\n");
                    break;
                }
                case INTRIN_TAN:
                case INTRIN_TANF:
                {
                    print("fptan\n");
                    print("fstp st0\n");
                    break;
                }
                case INTRIN_ATAN:
                case INTRIN_ATANF:
                {
                    print("fld1\n");
                    print("fpatan\n");
                    break;
                }
                case INTRIN_EXP:
                case INTRIN_EXPF:
                {
                    print("fldl2e\n");
                    print("fmulp st1\n");
                    print("fld st0\n");
                    print("frndint\n");
                    print("fxch st1\n");
                    print("fsub st0,st1\n");
                    print("f2xm1\n");
                    print("fld1\n");
                    print("faddp st1,st0\n");
                    print("fscale\n");
                    print("fstp st1\n");
                    break;
                }
                case INTRIN_LOG:
                case INTRIN_LOGF:
                {
                    print("fldln2\n");
                    print("fxch st1\n");
                    print("fyl2x\n");
                    break;
                }
                case INTRIN_LOG10:
                case INTRIN_LOG10F:
                {
                    print("fldlg2\n");
                    print("fxch st1\n");
                    print("fyl2x\n");
                    break;
                }
                case INTRIN_SIN:
                case INTRIN_SINF:
                {
                    print("fsin\n");
                    break;
                }
                case INTRIN_COS:
                case INTRIN_COSF:
                {
                    print("fcos\n");
                    break;
                }
                default:
                    assert(0);
                    break;
            }
            break;
        }

        case CBOOL+U+sizeop(1):
        {
            int dst = register_number(p);
            int src = register_number(p->x.kids[0]);
            switch (opsize(p->x.kids[0]->op))
            {
                case 8: print("mov %s,%s\nor %s,%s\n", intreg[dst]->x.name, intreg[src]->x.name, intreg[dst]->x.name, intreg[src-1]->x.name); break;
                case 4: print("cmp %s,0\n", intreg[src]->x.name); break;
                case 2: print("cmp %s,0\n", shortreg[src]->x.name); break;
                case 1: print("cmp %s,0\n", charreg[src]->x.name); break;
                default: assert(0);
            }
            print("setne %s\n", p->syms[RX]->x.name);
            break;
        }

        case LOAD+I+sizeop(1):
        case LOAD+I+sizeop(2):
        case LOAD+I+sizeop(4):
        case LOAD+U+sizeop(1):
        case LOAD+U+sizeop(2):
        case LOAD+U+sizeop(4):
        case LOAD+P+sizeop(4):
        {
            int dst = register_number(p);
            int src = register_number(p->x.kids[0]);
            if (dst != src)
                print("mov %s,%s\n", intreg[dst]->x.name, intreg[src]->x.name);
            break;
        }

        case LOAD+I+sizeop(8):
        case LOAD+U+sizeop(8):
        {
            int dst = register_number(p);
            int src = register_number(p->x.kids[0]);
            if (dst != src)
            {
                print("mov %s,%s\n", intreg[dst]->x.name, intreg[src]->x.name);
                print("mov %s,%s\n", intreg[dst-1]->x.name, intreg[src-1]->x.name);
            }
            break;
        }

        case ARG+I+sizeop(4):
        case ARG+U+sizeop(4):
        case ARG+P+sizeop(4):
        {
            /* push fastcall arguments not passed in registers */
            if (!argreg(p->x.argno, opsize(p->op)))
                print("push %s\n", intreg[register_number(p->x.kids[0])]->x.name);
            break;
        }

        case ARG+I+sizeop(8):
        case ARG+U+sizeop(8):
        {
            if (generic(p->kids[0]->op) == CNST)
            {
                uintmax_t v = p->kids[0]->syms[0]->u.c.v.u;
                print("push 0%xH\n", HI_DWORD(v));
                print("push 0%xH\n", LO_DWORD(v));
            }
            else
            {
                int dst = register_number(p->x.kids[0]);
                print("push %s\n", intreg[dst-1]->x.name);
                print("push %s\n", intreg[dst]->x.name);
            }
            break;
        }

        case RET+F+sizeop(4):
        case RET+F+sizeop(8):
        case RET+I+sizeop(4):
        case RET+I+sizeop(8):
        case RET+P+sizeop(4):
        case RET+U+sizeop(4):
        case RET+U+sizeop(8):
        case RET+V:
        {
            if (leafargs == 4)  /* leaf function - only return address on stack */
                print(retsize ? "ret %d\n" : "ret\n", retsize);
            /* faster and shorter to return, rather than *jump* to return */
            /* peephole optimizer will clean up: ret + jmp, ret + ret */
            break;
        }

        case ADDRF+P+sizeop(4):
        {
            if (leafargs)  /* leaf function */
                print("esp+(%d)", leafargs + p->syms[0]->x.offset - ARGOFFSET);
            else
                print("ebp+(%d)", p->syms[0]->x.offset);
            break;
        }

        case CVI+F+sizeop(4):
        case CVI+F+sizeop(8):
        {
            int src = register_number(p->x.kids[0]);
            if (opsize(p->x.kids[0]->op) == 4)
            {
                print("push %s\n", intreg[src]->x.name);
                print("fild dword [esp]\n");
                print("add esp,4\n");
            }
            else if (opsize(p->x.kids[0]->op) == 8)
            {
                print("push %s\n", intreg[src-1]->x.name);
                print("push %s\n", intreg[src]->x.name);
                print("fild qword [esp]\n");
                print("add esp,8\n");
            }
            else assert(0);
            break;
        }

        case CVI+I+sizeop(4):
        case CVI+U+sizeop(4):
        {
            int src = register_number(p->x.kids[0]);
            if (opsize(p->x.kids[0]->op) == 1)
                print("movsx %s,%s\n", p->syms[RX]->x.name, charreg[src]->x.name);
            else if (opsize(p->x.kids[0]->op) == 2)
                print("movsx %s,%s\n", p->syms[RX]->x.name, shortreg[src]->x.name);
            else if (opsize(p->x.kids[0]->op) == 4)
                print("mov %s,%s\n", p->syms[RX]->x.name, intreg[src]->x.name);
            else
                assert(0);
            break;
        }

        case CVU+I+sizeop(4):
        case CVU+U+sizeop(4):
        {
            int src = register_number(p->x.kids[0]);
            if (opsize(p->x.kids[0]->op) == 1)
                print("movzx %s,%s\n", p->syms[RX]->x.name, charreg[src]->x.name);
            else if (opsize(p->x.kids[0]->op) == 2)
                print("movzx %s,%s\n", p->syms[RX]->x.name, shortreg[src]->x.name);
            else if (opsize(p->x.kids[0]->op) == 4)
                print("mov %s,%s\n", p->syms[RX]->x.name, intreg[src]->x.name);
            else
                assert(0);
            break;
        }

        case CVI+I+sizeop(8):
        case CVI+U+sizeop(8):
        {
            int src = register_number(p->x.kids[0]);

            if (opsize(p->x.kids[0]->op) == 1)
                print("movsx %s,%s\n", p->syms[RX]->x.name, charreg[src]->x.name);
            else if (opsize(p->x.kids[0]->op) == 2)
                print("movsx %s,%s\n", p->syms[RX]->x.name, shortreg[src]->x.name);
            else if (opsize(p->x.kids[0]->op) == 4)
                print("mov %s,%s\n", p->syms[RX]->x.name, intreg[src]->x.name);

            /* sign extend the high doubleword */
            if (p->syms[RX]->x.name == intreg[EAX]->x.name)
            {
                print("cdq\n");
            }
            else if (p->syms[RX]->x.name == intreg[ECX]->x.name)
            {
                print("mov %s,%s\n", intreg[EBX]->x.name, p->syms[RX]->x.name);
                print("sar %s,31\n", intreg[EBX]->x.name);
            }
            else if (p->syms[RX]->x.name == intreg[ESI]->x.name)
            {
                print("mov %s,%s\n", intreg[EDI]->x.name, p->syms[RX]->x.name);
                print("sar %s,31\n", intreg[EDI]->x.name);
            }
            break;
        }

        case CVU+I+sizeop(8):
        case CVU+U+sizeop(8):
        {
            int src = register_number(p->x.kids[0]);

            if (opsize(p->x.kids[0]->op) == 1)
                print("movzx %s,%s\n", p->syms[RX]->x.name, charreg[src]->x.name);
            else if (opsize(p->x.kids[0]->op) == 2)
                print("movzx %s,%s\n", p->syms[RX]->x.name, shortreg[src]->x.name);
            else if (opsize(p->x.kids[0]->op) == 4)
                print("mov %s,%s\n", p->syms[RX]->x.name, intreg[src]->x.name);

            /* zero extend the high doubleword */
            if (p->syms[RX]->x.name == intreg[EAX]->x.name)
                print("mov %s,0\n", intreg[EDX]->x.name);
            else if (p->syms[RX]->x.name == intreg[ECX]->x.name)
                print("mov %s,0\n", intreg[EBX]->x.name);
            else if (p->syms[RX]->x.name == intreg[ESI]->x.name)
                print("mov %s,0\n", intreg[EDI]->x.name);
            break;
        }

        case CNST+I+sizeop(8):
        case CNST+U+sizeop(8):
        {
            int dst = register_number(p);
            uintmax_t v = p->syms[0]->u.c.v.u;
            print("mov %s,0%xH\n", intreg[dst]->x.name, LO_DWORD(v));
            print("mov %s,0%xH\n", intreg[dst-1]->x.name, HI_DWORD(v));
            break;
        }

        case ADD+I+sizeop(8):
        case ADD+U+sizeop(8):
        {
            if (generic(p->kids[1]->op) == CNST)
            {
                int dst = register_number(p);
                int src = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                if (dst != src)
                {
                    print("mov %s,%s\n", intreg[dst]->x.name, intreg[src]->x.name);
                    print("mov %s,%s\n", intreg[dst-1]->x.name, intreg[src-1]->x.name);
                }
                print("add %s,0%xH\n", intreg[dst]->x.name, LO_DWORD(v));
                print("adc %s,0%xH\n", intreg[dst-1]->x.name, HI_DWORD(v));
            }
            else
            {
                int dst = register_number(p);
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                if (dst == op1)  /* a = a + b */
                {
                    print("add %s,%s\n", intreg[dst]->x.name, intreg[op2]->x.name);
                    print("adc %s,%s\n", intreg[dst-1]->x.name, intreg[op2-1]->x.name);
                }
                else if (dst == op2)  /* b = a + b */
                {
                    print("add %s,%s\n", intreg[dst]->x.name, intreg[op1]->x.name);
                    print("adc %s,%s\n", intreg[dst-1]->x.name, intreg[op1-1]->x.name);
                }
                else  /* a = b + c */
                {
                    print("mov %s,%s\n", intreg[dst]->x.name, intreg[op1]->x.name);
                    print("mov %s,%s\n", intreg[dst-1]->x.name, intreg[op1-1]->x.name);
                    print("add %s,%s\n", intreg[dst]->x.name, intreg[op2]->x.name);
                    print("adc %s,%s\n", intreg[dst-1]->x.name, intreg[op2-1]->x.name);
                }
            }
            break;
        }

        case SUB+I+sizeop(8):
        case SUB+U+sizeop(8):
        {
            if (generic(p->kids[1]->op) == CNST)
            {
                int dst = register_number(p);
                int src = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                if (dst != src)
                {
                    print("mov %s,%s\n", intreg[dst]->x.name, intreg[src]->x.name);
                    print("mov %s,%s\n", intreg[dst-1]->x.name, intreg[src-1]->x.name);
                }
                print("sub %s,0%xH\n", intreg[dst]->x.name, LO_DWORD(v));
                print("sbb %s,0%xH\n", intreg[dst-1]->x.name, HI_DWORD(v));
            }
            else
            {
                int dst = register_number(p);
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                if (dst == op1)  /* a = a - b */
                {
                    print("sub %s,%s\n", intreg[dst]->x.name, intreg[op2]->x.name);
                    print("sbb %s,%s\n", intreg[dst-1]->x.name, intreg[op2-1]->x.name);
                }
                else if (dst == op2)  /* b = a - b => -b + a */
                {
                    print("neg %s\n", intreg[dst]->x.name);
                    print("adc %s,byte 0\n", intreg[dst-1]->x.name);
                    print("neg %s\n", intreg[dst-1]->x.name);
                    print("add %s,%s\n", intreg[dst]->x.name, intreg[op1]->x.name);
                    print("adc %s,%s\n", intreg[dst-1]->x.name, intreg[op1-1]->x.name);
                }
                else  /* a = b - c */
                {
                    print("mov %s,%s\n", intreg[dst]->x.name, intreg[op1]->x.name);
                    print("mov %s,%s\n", intreg[dst-1]->x.name, intreg[op1-1]->x.name);
                    print("sub %s,%s\n", intreg[dst]->x.name, intreg[op2]->x.name);
                    print("sbb %s,%s\n", intreg[dst-1]->x.name, intreg[op2-1]->x.name);
                }
            }
            break;
        }

        case MUL+I+sizeop(8):
        case MUL+U+sizeop(8):
        {
            /* target is always EDX:EAX */
            if (generic(p->kids[1]->op) == CNST)
            {
                int op1 = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                print("push %s\n", intreg[op1-1]->x.name);
                print("push %s\n", intreg[op1]->x.name);
                print("push 0%xH\n", HI_DWORD(v));
                print("push 0%xH\n", LO_DWORD(v));
                print("call ___llmul\n");
                rtimp[RT_LLMUL] = 1;
            }
            else
            {
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                print("push %s\n", intreg[op1-1]->x.name);
                print("push %s\n", intreg[op1]->x.name);
                print("push %s\n", intreg[op2-1]->x.name);
                print("push %s\n", intreg[op2]->x.name);
                print("call ___llmul\n");
                rtimp[RT_LLMUL] = 1;
            }
            break;
        }

        case DIV+I+sizeop(8):
        {
            /* target is always EDX:EAX */
            if (generic(p->kids[1]->op) == CNST)
            {
                int op1 = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                print("push %s\n", intreg[op1-1]->x.name);
                print("push %s\n", intreg[op1]->x.name);
                print("push 0%xH\n", HI_DWORD(v));
                print("push 0%xH\n", LO_DWORD(v));
                print("call ___lldiv\n");
                rtimp[RT_LLDIV] = 1;
            }
            else
            {
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                print("push %s\n", intreg[op1-1]->x.name);
                print("push %s\n", intreg[op1]->x.name);
                print("push %s\n", intreg[op2-1]->x.name);
                print("push %s\n", intreg[op2]->x.name);
                print("call ___lldiv\n");
                rtimp[RT_LLDIV] = 1;
            }
            break;
        }

        case DIV+U+sizeop(8):
        {
            /* target is always EDX:EAX */
            if (generic(p->kids[1]->op) == CNST)
            {
                int op1 = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                print("push %s\n", intreg[op1-1]->x.name);
                print("push %s\n", intreg[op1]->x.name);
                print("push 0%xH\n", HI_DWORD(v));
                print("push 0%xH\n", LO_DWORD(v));
                print("call ___ulldiv\n");
                rtimp[RT_ULLDIV] = 1;
            }
            else
            {
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                print("push %s\n", intreg[op1-1]->x.name);
                print("push %s\n", intreg[op1]->x.name);
                print("push %s\n", intreg[op2-1]->x.name);
                print("push %s\n", intreg[op2]->x.name);
                print("call ___ulldiv\n");
                rtimp[RT_ULLDIV] = 1;
            }
            break;
        }

        case MOD+I+sizeop(8):
        {
            /* target is always EDX:EAX */
            if (generic(p->kids[1]->op) == CNST)
            {
                int op1 = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                print("push %s\n", intreg[op1-1]->x.name);
                print("push %s\n", intreg[op1]->x.name);
                print("push 0%xH\n", HI_DWORD(v));
                print("push 0%xH\n", LO_DWORD(v));
                print("call ___llmod\n");
                rtimp[RT_LLMOD] = 1;
            }
            else
            {
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                print("push %s\n", intreg[op1-1]->x.name);
                print("push %s\n", intreg[op1]->x.name);
                print("push %s\n", intreg[op2-1]->x.name);
                print("push %s\n", intreg[op2]->x.name);
                print("call ___llmod\n");
                rtimp[RT_LLMOD] = 1;
            }
            break;
        }

        case MOD+U+sizeop(8):
        {
            /* target is always EDX:EAX */
            if (generic(p->kids[1]->op) == CNST)
            {
                int op1 = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                print("push %s\n", intreg[op1-1]->x.name);
                print("push %s\n", intreg[op1]->x.name);
                print("push 0%xH\n", HI_DWORD(v));
                print("push 0%xH\n", LO_DWORD(v));
                print("call ___ullmod\n");
                rtimp[RT_ULLMOD] = 1;
            }
            else
            {
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                print("push %s\n", intreg[op1-1]->x.name);
                print("push %s\n", intreg[op1]->x.name);
                print("push %s\n", intreg[op2-1]->x.name);
                print("push %s\n", intreg[op2]->x.name);
                print("call ___ullmod\n");
                rtimp[RT_ULLMOD] = 1;
            }
            break;
        }

        case BAND+I+sizeop(8):
        case BAND+U+sizeop(8):
        {
            if (generic(p->kids[1]->op) == CNST)
            {
                int dst = register_number(p);
                int src = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                if (dst != src)
                {
                    print("mov %s,%s\n", intreg[dst]->x.name, intreg[src]->x.name);
                    print("mov %s,%s\n", intreg[dst-1]->x.name, intreg[src-1]->x.name);
                }
                print("and %s,0%xH\n", intreg[dst]->x.name, LO_DWORD(v));
                print("and %s,0%xH\n", intreg[dst-1]->x.name, HI_DWORD(v));
            }
            else
            {
                int dst = register_number(p);
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                if (dst == op1)  /* a = a & b */
                {
                    print("and %s,%s\n", intreg[dst]->x.name, intreg[op2]->x.name);
                    print("and %s,%s\n", intreg[dst-1]->x.name, intreg[op2-1]->x.name);
                }
                else if (dst == op2)  /* b = a & b */
                {
                    print("and %s,%s\n", intreg[dst]->x.name, intreg[op1]->x.name);
                    print("and %s,%s\n", intreg[dst-1]->x.name, intreg[op1-1]->x.name);
                }
                else  /* a = b & c */
                {
                    print("mov %s,%s\n", intreg[dst]->x.name, intreg[op1]->x.name);
                    print("mov %s,%s\n", intreg[dst-1]->x.name, intreg[op1-1]->x.name);
                    print("and %s,%s\n", intreg[dst]->x.name, intreg[op2]->x.name);
                    print("and %s,%s\n", intreg[dst-1]->x.name, intreg[op2-1]->x.name);
                }
            }
            break;
        }

        case BOR+I+sizeop(8):
        case BOR+U+sizeop(8):
        {
            if (generic(p->kids[1]->op) == CNST)
            {
                int dst = register_number(p);
                int src = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                if (dst != src)
                {
                    print("mov %s,%s\n", intreg[dst]->x.name, intreg[src]->x.name);
                    print("mov %s,%s\n", intreg[dst-1]->x.name, intreg[src-1]->x.name);
                }
                print("or %s,0%xH\n", intreg[dst]->x.name, LO_DWORD(v));
                print("or %s,0%xH\n", intreg[dst-1]->x.name, HI_DWORD(v));
            }
            else
            {
                int dst = register_number(p);
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                if (dst == op1)  /* a = a | b */
                {
                    print("or %s,%s\n", intreg[dst]->x.name, intreg[op2]->x.name);
                    print("or %s,%s\n", intreg[dst-1]->x.name, intreg[op2-1]->x.name);
                }
                else if (dst == op2)  /* b = a | b */
                {
                    print("or %s,%s\n", intreg[dst]->x.name, intreg[op1]->x.name);
                    print("or %s,%s\n", intreg[dst-1]->x.name, intreg[op1-1]->x.name);
                }
                else  /* a = b | c */
                {
                    print("mov %s,%s\n", intreg[dst]->x.name, intreg[op1]->x.name);
                    print("mov %s,%s\n", intreg[dst-1]->x.name, intreg[op1-1]->x.name);
                    print("or %s,%s\n", intreg[dst]->x.name, intreg[op2]->x.name);
                    print("or %s,%s\n", intreg[dst-1]->x.name, intreg[op2-1]->x.name);
                }
            }
            break;
        }

        case BXOR+I+sizeop(8):
        case BXOR+U+sizeop(8):
        {
            if (generic(p->kids[1]->op) == CNST)
            {
                int dst = register_number(p);
                int src = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                if (dst != src)
                {
                    print("mov %s,%s\n", intreg[dst]->x.name, intreg[src]->x.name);
                    print("mov %s,%s\n", intreg[dst-1]->x.name, intreg[src-1]->x.name);
                }
                print("xor %s,0%xH\n", intreg[dst]->x.name, LO_DWORD(v));
                print("xor %s,0%xH\n", intreg[dst-1]->x.name, HI_DWORD(v));
            }
            else
            {
                int dst = register_number(p);
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                if (dst == op1)  /* a = a ^ b */
                {
                    print("xor %s,%s\n", intreg[dst]->x.name, intreg[op2]->x.name);
                    print("xor %s,%s\n", intreg[dst-1]->x.name, intreg[op2-1]->x.name);
                }
                else if (dst == op2)  /* b = a ^ b */
                {
                    print("xor %s,%s\n", intreg[dst]->x.name, intreg[op1]->x.name);
                    print("xor %s,%s\n", intreg[dst-1]->x.name, intreg[op1-1]->x.name);
                }
                else  /* a = b ^ c */
                {
                    print("mov %s,%s\n", intreg[dst]->x.name, intreg[op1]->x.name);
                    print("mov %s,%s\n", intreg[dst-1]->x.name, intreg[op1-1]->x.name);
                    print("xor %s,%s\n", intreg[dst]->x.name, intreg[op2]->x.name);
                    print("xor %s,%s\n", intreg[dst-1]->x.name, intreg[op2-1]->x.name);
                }
            }
            break;
        }

        case LSH+I+sizeop(8):
        case LSH+U+sizeop(8):
        {
            /* target is always EDX:EAX */
            int src = register_number(p->x.kids[0]);
            if (generic(p->kids[1]->op) == CNST)  /* shift value is constant */
            {
                uint_t shift = (uint_t)p->kids[1]->syms[0]->u.c.v.u;
                int dst = register_number(p);
                if (shift <= 31)
                {
                    if (dst != src)
                    {
                        print("mov %s,%s\n", intreg[dst]->x.name, intreg[src]->x.name);
                        print("mov %s,%s\n", intreg[dst-1]->x.name, intreg[src-1]->x.name);
                    }
                    print("shld %s,%s,%u\n", intreg[dst-1]->x.name, intreg[dst]->x.name, shift);
                    print("shl %s,%u\n", intreg[dst]->x.name, shift);
                }
                else if (shift == 32)
                {
                    print("mov %s,%s\n", intreg[dst-1]->x.name, intreg[src]->x.name);
                    print("mov %s,0\n", intreg[dst]->x.name);
                }
                else
                {
                    print("push %s\n", intreg[src-1]->x.name);
                    print("push %s\n", intreg[src]->x.name);
                    print("push %u\n", shift);
                    print("call ___llshl\n");
                    rtimp[RT_LLSHL] = 1;
                }
            }
            else /* shift value in register */
            {
                int shift = register_number(p->x.kids[1]);
                print("push %s\n", intreg[src-1]->x.name);
                print("push %s\n", intreg[src]->x.name);
                print("push %s\n", intreg[shift]->x.name);
                print("call ___llshl\n");
                rtimp[RT_LLSHL] = 1;
            }
            break;
        }

        case RSH+I+sizeop(8):
        {
            /* target is always EDX:EAX */
            int src = register_number(p->x.kids[0]);
            if (generic(p->kids[1]->op) == CNST)  /* shift value is constant */
            {
                uint_t shift = (uint_t)p->kids[1]->syms[0]->u.c.v.u;
                print("push %s\n", intreg[src-1]->x.name);
                print("push %s\n", intreg[src]->x.name);
                print("push %u\n", shift);
                print("call ___llshr\n");
                rtimp[RT_LLSHR] = 1;
            }
            else /* shift value in register */
            {
                int shift = register_number(p->x.kids[1]);
                print("push %s\n", intreg[src-1]->x.name);
                print("push %s\n", intreg[src]->x.name);
                print("push %s\n", intreg[shift]->x.name);
                print("call ___llshr\n");
                rtimp[RT_LLSHR] = 1;
            }
            break;
        }

        case RSH+U+sizeop(8):
        {
            /* target is always EDX:EAX */
            int src = register_number(p->x.kids[0]);
            if (generic(p->kids[1]->op) == CNST)  /* shift value is constant */
            {
                uint_t shift = (uint_t)p->kids[1]->syms[0]->u.c.v.u;
                int dst = register_number(p);
                if (shift <= 31)
                {
                    if (dst != src)
                    {
                        print("mov %s,%s\n", intreg[dst]->x.name, intreg[src]->x.name);
                        print("mov %s,%s\n", intreg[dst-1]->x.name, intreg[src-1]->x.name);
                    }
                    print("shrd %s,%s,%u\n", intreg[dst]->x.name, intreg[dst-1]->x.name, shift);
                    print("shr %s,%u\n", intreg[dst-1]->x.name, shift);
                }
                else if (shift == 32)
                {
                    print("mov %s,%s\n", intreg[dst]->x.name, intreg[src-1]->x.name);
                    print("mov %s,0\n", intreg[dst-1]->x.name);
                }
                else
                {
                    print("push %s\n", intreg[src-1]->x.name);
                    print("push %s\n", intreg[src]->x.name);
                    print("push %u\n", shift);
                    print("call ___ullshr\n");
                    rtimp[RT_ULLSHR] = 1;
                }
            }
            else /* shift value in register */
            {
                int shift = register_number(p->x.kids[1]);
                print("push %s\n", intreg[src-1]->x.name);
                print("push %s\n", intreg[src]->x.name);
                print("push %s\n", intreg[shift]->x.name);
                print("call ___ullshr\n");
                rtimp[RT_ULLSHR] = 1;
            }
            break;
        }

        case INDIR+I+sizeop(8):
        case INDIR+U+sizeop(8):
        {
            if (generic(p->kids[0]->op) != VREG)
            {
                int dst = register_number(p);

                /* avoid self-destructive tendencies */
                if (clobber_register(p->kids[0]) == dst)
                {
                    /* change mov eax,[eax] : mov edx,[eax+4] to mov edx,[eax+4] : mov eax,[eax] */
                    print("mov %s,[", intreg[dst-1]->x.name); emitasm(p->kids[0], _laddr_NT); print("+4]\n");
                    print("mov %s,[", intreg[dst]->x.name); emitasm(p->kids[0], _laddr_NT); print("]\n");
                }
                else
                {
                    print("mov %s,[", intreg[dst]->x.name); emitasm(p->kids[0], _laddr_NT); print("]\n");
                    print("mov %s,[", intreg[dst-1]->x.name); emitasm(p->kids[0], _laddr_NT); print("+4]\n");
                }
            }
            break;
        }

        case ASGN+I+sizeop(8):
        case ASGN+U+sizeop(8):
        {
            if (generic(p->kids[0]->op) != VREG)
            {
                if (generic(p->kids[1]->op) == CNST)
                {
                    uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                    print("mov dword ["); emitasm(p->kids[0], _laddr_NT); print("],0%xH\n", LO_DWORD(v));
                    print("mov dword ["); emitasm(p->kids[0], _laddr_NT); print("+4],0%xH\n", HI_DWORD(v));
                }
                else
                {
                    int src = register_number(p->kids[1]);
                    print("mov ["); emitasm(p->kids[0], _laddr_NT); print("],%s\n", intreg[src]->x.name);
                    print("mov ["); emitasm(p->kids[0], _laddr_NT); print("+4],%s\n", intreg[src-1]->x.name);
                }
            }
            break;
        }

        case BCOM+I+sizeop(8):
        case BCOM+U+sizeop(8):
        {
            int dst = register_number(p);
            int src = register_number(p->x.kids[0]);
            if (dst != src)
            {
                print("mov %s,%s\n", intreg[dst]->x.name, intreg[src]->x.name);
                print("mov %s,%s\n", intreg[dst-1]->x.name, intreg[src-1]->x.name);
            }
            print("not %s\n", intreg[dst]->x.name);
            print("not %s\n", intreg[dst-1]->x.name);
            break;
        }

        case NEG+I+sizeop(8):
        {
            int dst = register_number(p);
            int src = register_number(p->x.kids[0]);
            if (dst != src)
            {
                print("mov %s,%s\n", intreg[dst]->x.name, intreg[src]->x.name);
                print("mov %s,%s\n", intreg[dst-1]->x.name, intreg[src-1]->x.name);
            }
            print("neg %s\n", intreg[dst]->x.name);
            print("adc %s,byte 0\n", intreg[dst-1]->x.name);
            print("neg %s\n", intreg[dst-1]->x.name);
            break;
        }

        case EQ+I+sizeop(8):
        case EQ+U+sizeop(8):
        {
            if (generic(p->kids[1]->op) == CNST)
            {
                int op1 = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                int lab = make_label(1);
                print("cmp %s,0%xH\n", intreg[op1-1]->x.name, HI_DWORD(v));
                print("jne near @%d\n", lab);
                print("cmp %s,0%xH\n", intreg[op1]->x.name, LO_DWORD(v));
                print("je near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            else
            {
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                int lab = make_label(1);
                print("cmp %s,%s\n", intreg[op1-1]->x.name, intreg[op2-1]->x.name);
                print("jne near @%d\n", lab);
                print("cmp %s,%s\n", intreg[op1]->x.name, intreg[op2]->x.name);
                print("je near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            break;
        }

        case NE+I+sizeop(8):
        case NE+U+sizeop(8):
        {
            if (generic(p->kids[1]->op) == CNST)
            {
                int op1 = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                print("cmp %s,0%xH\n", intreg[op1-1]->x.name, HI_DWORD(v));
                print("jne near %s\n", p->syms[0]->x.name);
                print("cmp %s,0%xH\n", intreg[op1]->x.name, LO_DWORD(v));
                print("jne near %s\n", p->syms[0]->x.name);
            }
            else
            {
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                print("cmp %s,%s\n", intreg[op1-1]->x.name, intreg[op2-1]->x.name);
                print("jne near %s\n", p->syms[0]->x.name);
                print("cmp %s,%s\n", intreg[op1]->x.name, intreg[op2]->x.name);
                print("jne near %s\n", p->syms[0]->x.name);
            }
            break;
        }

        case GE+I+sizeop(8):
        {
            if (generic(p->kids[1]->op) == CNST)
            {
                int op1 = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                int lab = make_label(1);
                print("cmp %s,0%xH\n", intreg[op1-1]->x.name, HI_DWORD(v));
                print("jg near %s\n", p->syms[0]->x.name);
                print("jl near @%d\n", lab);
                print("cmp %s,0%xH\n", intreg[op1]->x.name, LO_DWORD(v));
                print("jae near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            else
            {
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                int lab = make_label(1);
                print("cmp %s,%s\n", intreg[op1-1]->x.name, intreg[op2-1]->x.name);
                print("jg near %s\n", p->syms[0]->x.name);
                print("jl near @%d\n", lab);
                print("cmp %s,%s\n", intreg[op1]->x.name, intreg[op2]->x.name);
                print("jae near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            break;
        }

        case GE+U+sizeop(8):
        {
            if (generic(p->kids[1]->op) == CNST)
            {
                int op1 = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                int lab = make_label(1);
                print("cmp %s,0%xH\n", intreg[op1-1]->x.name, HI_DWORD(v));
                print("ja near %s\n", p->syms[0]->x.name);
                print("jb near @%d\n", lab);
                print("cmp %s,0%xH\n", intreg[op1]->x.name, LO_DWORD(v));
                print("jae near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            else
            {
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                int lab = make_label(1);
                print("cmp %s,%s\n", intreg[op1-1]->x.name, intreg[op2-1]->x.name);
                print("ja near %s\n", p->syms[0]->x.name);
                print("jb near @%d\n", lab);
                print("cmp %s,%s\n", intreg[op1]->x.name, intreg[op2]->x.name);
                print("jae near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            break;
        }

        case GT+I+sizeop(8):
        {
            if (generic(p->kids[1]->op) == CNST)
            {
                int op1 = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                int lab = make_label(1);
                print("cmp %s,0%xH\n", intreg[op1-1]->x.name, HI_DWORD(v));
                print("jg near %s\n", p->syms[0]->x.name);
                print("jl near @%d\n", lab);
                print("cmp %s,0%xH\n", intreg[op1]->x.name, LO_DWORD(v));
                print("ja near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            else
            {
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                int lab = make_label(1);
                print("cmp %s,%s\n", intreg[op1-1]->x.name, intreg[op2-1]->x.name);
                print("jg near %s\n", p->syms[0]->x.name);
                print("jl near @%d\n", lab);
                print("cmp %s,%s\n", intreg[op1]->x.name, intreg[op2]->x.name);
                print("ja near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            break;
        }

        case GT+U+sizeop(8):
        {
            if (generic(p->kids[1]->op) == CNST)
            {
                int op1 = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                int lab = make_label(1);
                print("cmp %s,0%xH\n", intreg[op1-1]->x.name, HI_DWORD(v));
                print("ja near %s\n", p->syms[0]->x.name);
                print("jb near @%d\n", lab);
                print("cmp %s,0%xH\n", intreg[op1]->x.name, LO_DWORD(v));
                print("ja near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            else
            {
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                int lab = make_label(1);
                print("cmp %s,%s\n", intreg[op1-1]->x.name, intreg[op2-1]->x.name);
                print("ja near %s\n", p->syms[0]->x.name);
                print("jb near @%d\n", lab);
                print("cmp %s,%s\n", intreg[op1]->x.name, intreg[op2]->x.name);
                print("ja near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            break;
        }

        case LE+I+sizeop(8):
        {
            if (generic(p->kids[1]->op) == CNST)
            {
                int op1 = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                int lab = make_label(1);
                print("cmp %s,0%xH\n", intreg[op1-1]->x.name, HI_DWORD(v));
                print("jl near %s\n", p->syms[0]->x.name);
                print("jg near @%d\n", lab);
                print("cmp %s,0%xH\n", intreg[op1]->x.name, LO_DWORD(v));
                print("jbe near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            else
            {
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                int lab = make_label(1);
                print("cmp %s,%s\n", intreg[op1-1]->x.name, intreg[op2-1]->x.name);
                print("jl near %s\n", p->syms[0]->x.name);
                print("jg near @%d\n", lab);
                print("cmp %s,%s\n", intreg[op1]->x.name, intreg[op2]->x.name);
                print("jbe near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            break;
        }

        case LE+U+sizeop(8):
        {
            if (generic(p->kids[1]->op) == CNST)
            {
                int op1 = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                int lab = make_label(1);
                print("cmp %s,0%xH\n", intreg[op1-1]->x.name, HI_DWORD(v));
                print("jb near %s\n", p->syms[0]->x.name);
                print("ja near @%d\n", lab);
                print("cmp %s,0%xH\n", intreg[op1]->x.name, LO_DWORD(v));
                print("jbe near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            else
            {
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                int lab = make_label(1);
                print("cmp %s,%s\n", intreg[op1-1]->x.name, intreg[op2-1]->x.name);
                print("jb near %s\n", p->syms[0]->x.name);
                print("ja near @%d\n", lab);
                print("cmp %s,%s\n", intreg[op1]->x.name, intreg[op2]->x.name);
                print("jbe near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            break;
        }

        case LT+I+sizeop(8):
        {
            if (generic(p->kids[1]->op) == CNST)
            {
                int op1 = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                int lab = make_label(1);
                print("cmp %s,0%xH\n", intreg[op1-1]->x.name, HI_DWORD(v));
                print("jl near %s\n", p->syms[0]->x.name);
                print("jg near @%d\n", lab);
                print("cmp %s,0%xH\n", intreg[op1]->x.name, LO_DWORD(v));
                print("jb near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            else
            {
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                int lab = make_label(1);
                print("cmp %s,%s\n", intreg[op1-1]->x.name, intreg[op2-1]->x.name);
                print("jl near %s\n", p->syms[0]->x.name);
                print("jg near @%d\n", lab);
                print("cmp %s,%s\n", intreg[op1]->x.name, intreg[op2]->x.name);
                print("jb near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            break;
        }

        case LT+U+sizeop(8):
        {
            if (generic(p->kids[1]->op) == CNST)
            {
                int op1 = register_number(p->x.kids[0]);
                uintmax_t v = p->kids[1]->syms[0]->u.c.v.u;
                int lab = make_label(1);
                print("cmp %s,0%xH\n", intreg[op1-1]->x.name, HI_DWORD(v));
                print("jb near %s\n", p->syms[0]->x.name);
                print("ja near @%d\n", lab);
                print("cmp %s,0%xH\n", intreg[op1]->x.name, LO_DWORD(v));
                print("jb near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            else
            {
                int op1 = register_number(p->x.kids[0]);
                int op2 = register_number(p->x.kids[1]);
                int lab = make_label(1);
                print("cmp %s,%s\n", intreg[op1-1]->x.name, intreg[op2-1]->x.name);
                print("jb near %s\n", p->syms[0]->x.name);
                print("ja near @%d\n", lab);
                print("cmp %s,%s\n", intreg[op1]->x.name, intreg[op2]->x.name);
                print("jb near %s\n", p->syms[0]->x.name);
                print("@%d:\n", lab);
            }
            break;
        }

        case DIV+U+sizeop(4):
        {
            uint_t d = (uint_t)p->kids[1]->syms[0]->u.c.v.u;  /* divisor */
            uint_t s = msb(d);

            assert (generic(p->kids[1]->op) == CNST);
            assert(register_number(p->x.kids[0]) == EAX);
            assert(register_number(p) == EAX);

            if (d == 0)
            {
                /* divide by zero */
                print("xor eax,eax\ndiv eax\n");
            }
            else
            {
                uint_t m = (uint_t)(((uintmax_t)1 << (32 + s)) / d);
                uint_t x = (uint_t)(((uintmax_t)1 << (32 + s)) % d);

                assert(x != 0);  /* should be RSHU4 */

                if (x*2 < d)
                {
                    /* round down to nearest integer */
                    print("mov edx,%u\n", m);
                    print("mul edx\n");
                    print("add eax,%u\n", m);
                    print("adc edx,0\n");
                    print("shr edx,%u\n", s);
                    print("mov eax,edx\n");
                }
                else
                {
                    /* round up to nearest integer */
                    print("mov edx,%u\n", m + 1);
                    print("mul edx\n");
                    print("shr edx,%u\n", s);
                    print("mov eax,edx\n");
                }
            }
            break;
        }

        case DIV+I+sizeop(4):
        {
            int v = (int)p->kids[1]->syms[0]->u.c.v.i;  /* divisor */
            uint_t d = abs(v);
            uint_t s = msb(d);

            assert (generic(p->kids[1]->op) == CNST);
            assert(register_number(p->x.kids[0]) == EAX);
            assert(register_number(p) == EAX);

            if (d == 0)
            {
                /* divide by zero */
                print("xor eax,eax\nidiv eax\n");
            }
            else if (d > 1 && (d & (d-1)) == 0)
            {
                print("cdq\n");
                print(d == 2 ? "sub eax,edx\n" : "and edx,%u\nadd eax,edx\n", d - 1);
                print("sar eax,%u\n", s);
                if (v < 0) print("neg eax\n");
            }
            else
            {
                uintmax_t lo = (((uintmax_t)1 << (32 + s))) / d;
                uintmax_t hi = (((uintmax_t)1 << (32 + s)) + ((uintmax_t)1 << (32 + s - 31))) / d;
                int m;

                /* reduce to lowest terms */
                while (lo/2 < hi/2 && s > 0)
                    lo /= 2, hi /= 2, s--;

                m = (int)hi;

                if (m < 0)
                {
                    print("push eax\n");
                    print("mov edx,%u\n", m);
                    print("imul edx\n");
                    print("pop eax\n");
                    print("add edx,eax\n");
                    print("shr eax,31\n");
                    if (s > 0) print("sar edx,%u\n", s);
                    print("add eax,edx\n");
                    if (v < 0) print("neg eax\n");
                }
                else
                {
                    print("push eax\n");
                    print("mov edx,%u\n", m);
                    print("imul edx\n");
                    print("pop eax\n");
                    print("shr eax,31\n");
                    if (s > 0) print("sar edx,%u\n", s);
                    print("add eax,edx\n");
                    if (v < 0) print("neg eax\n");
                }
            }
            break;
        }
    }
}
#undef LO_DWORD
#undef HI_DWORD

/****************************************************************************
 *                                                                          *
 * Function: msb                                                            *
 *                                                                          *
 * Purpose : Return index of the higest bit set (from zero).                *
 *                                                                          *
 * History : Date      Reason                                               *
 *           04-12-18  Created                                              *
 *                                                                          *
 ****************************************************************************/

static int msb(unsigned int u)
{
    int n = 0;

    if (u & 0xFFFF0000U) { u >>= 16;  n += 16; }
    if (u & 0x0000FF00U) { u >>=  8;  n +=  8; }
    if (u & 0x000000F0U) { u >>=  4;  n +=  4; }
    if (u & 0x0000000CU) { u >>=  2;  n +=  2; }
    if (u & 0x00000002U) {            n +=  1; }

    return n;
}

/****************************************************************************
 *                                                                          *
 * Function: clobber_register                                               *
 *                                                                          *
 * Purpose : Check for clobbering register in INDIRI8/INDIRU8 address.      *
 *                                                                          *
 * History : Date      Reason                                               *
 *           04-07-09  Created                                              *
 *                                                                          *
 ****************************************************************************/

static int clobber_register(NODE *p)
{
    int rn = -1;
    if (p)
    {
        if (p->syms[RX] && p->syms[RX]->x.regnode)
            rn = register_number(p);

        if (rn == -1)
            rn = clobber_register(p->kids[0]);

        if (rn == -1)
            rn = clobber_register(p->kids[1]);
    }
    return rn;
}

static void blkfetch(int size, int off, int reg, int tmp) {}
static void blkstore(int size, int off, int reg, int tmp) {}
static void blkloop(int dreg, int doff, int sreg, int soff, int size, int tmps[]) {}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::progbeg                                             *
 *                                                                          *
 * Purpose : Initialize the code generation (back end).                     *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *           04-07-09  Finally removed virtual registers a64, b64, c64!     *
 *                                                                          *
 ****************************************************************************/

static void I(progbeg)(void)
{
    int i;

    charreg[EAX] = mkreg("al", EAX, 1, IREG);
    charreg[EBX] = mkreg("bl", EBX, 1, IREG);
    charreg[ECX] = mkreg("cl", ECX, 1, IREG);
    charreg[EDX] = mkreg("dl", EDX, 1, IREG);

    shortreg[EAX] = mkreg("ax", EAX, 1, IREG);
    shortreg[EBX] = mkreg("bx", EBX, 1, IREG);
    shortreg[ECX] = mkreg("cx", ECX, 1, IREG);
    shortreg[EDX] = mkreg("dx", EDX, 1, IREG);
    shortreg[EDI] = mkreg("di", EDI, 1, IREG);
    shortreg[ESI] = mkreg("si", ESI, 1, IREG);

    intreg[EAX] = mkreg("eax", EAX, 1, IREG);
    intreg[EBX] = mkreg("ebx", EBX, 1, IREG);
    intreg[ECX] = mkreg("ecx", ECX, 1, IREG);
    intreg[EDX] = mkreg("edx", EDX, 1, IREG);
    intreg[EDI] = mkreg("edi", EDI, 1, IREG);
    intreg[ESI] = mkreg("esi", ESI, 1, IREG);

    longreg[EAX] = mkreg("eax", EAX, 1, IREG);
    longreg[EAX]->x.regnode->mask |= 1<<EDX;            /* EAX and EDX (lo:hi) */
    longreg[ECX] = mkreg("ecx", ECX, 1, IREG);
    longreg[ECX]->x.regnode->mask |= 1<<EBX;            /* ECX and EBX (lo:hi) */
    longreg[ESI] = mkreg("esi", ESI, 1, IREG);
    longreg[ESI]->x.regnode->mask |= 1<<EDI;            /* ESI and EDI (lo:hi) */

    for (i = 0; i < 8; i++)
        fltreg[i] = mkreg("%d", i, 0, FREG);

    charregw = mkwildcard(charreg);
    shortregw = mkwildcard(shortreg);
    intregw = mkwildcard(intreg);
    longregw = mkwildcard(longreg);
    fltregw = mkwildcard(fltreg);

    tmask[IREG] = (1<<EDI|1<<ESI|1<<EBX|1<<EDX|1<<ECX|1<<EAX);
    vmask[IREG] = 0;

    tmask[FREG] = 0xff;
    vmask[FREG] = 0;

    cseg = 0;

    /* set appropriate processor level (see x86emit.c) */
    print(options.maxopt ? "[cpu ppro]\n" : "[cpu 486]\n");
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::progend                                             *
 *                                                                          *
 * Purpose : Finalize the code generation (back end).                       *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *           03-08-01  Indirect call to finalize_initexit() added.          *
 *           03-10-19  Added optional output of 'oldnames.lib'.             *
 *           04-06-27  Added optional output of 'pocrt.lib'.                *
 *           04-12-12  Added rtimp[RT_CHKSTK].                              *
 *                                                                          *
 ****************************************************************************/

static void I(progend)(void)
{
    if (rtimp[RT_FTOL]) print("[extern ___ftol]\n");
    if (rtimp[RT_FTOLL]) print("[extern ___ftoll]\n");
    if (rtimp[RT_LLSHL]) print("[extern ___llshl]\n");
    if (rtimp[RT_LLSHR]) print("[extern ___llshr]\n");
    if (rtimp[RT_ULLSHR]) print("[extern ___ullshr]\n");
    if (rtimp[RT_LLMUL]) print("[extern ___llmul]\n");
    if (rtimp[RT_LLDIV]) print("[extern ___lldiv]\n");
    if (rtimp[RT_ULLDIV]) print("[extern ___ulldiv]\n");
    if (rtimp[RT_LLMOD]) print("[extern ___llmod]\n");
    if (rtimp[RT_ULLMOD]) print("[extern ___ullmod]\n");
    if (rtimp[RT_UNWIND]) print("[extern __local_unwind2]\n");
    if (rtimp[RT_CHKSTK]) print("[extern ___chkstk]\n");

    /* finalize startup and exit procedures */
    for_each_symbol(identifiers, GLOBAL, finalize_initexit, NULL);

    if (options.defaultlib)
    {
        (*IR->segment)(DRECTVE);

        if (options.crtdll)
            print("db \" -defaultlib:pocrt\"\n");
        else  /* static runtime */
            print(options.multithread ? "db \" -defaultlib:crtmt\"\n" : "db \" -defaultlib:crt\"\n");

        if (options.oldnames)
            print("db \" -defaultlib:oldnames\"\n");
    }
}

/****************************************************************************
 *                                                                          *
 * Function: finalize_initexit                                              *
 *                                                                          *
 * Purpose : Finalize the startup and exit procedures.                      *
 *                                                                          *
 * History : Date      Reason                                               *
 *           03-08-01  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void finalize_initexit(SYMBOL *sym, void *cl)
{
    if (sym->init)
    {
        (*IR->segment)(INITFN);
        print("dd %s\n", sym->x.name);
    }
    if (sym->exit)
    {
        (*IR->segment)(EXITFN);
        print("dd %s\n", sym->x.name);
    }
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::function                                            *
 *                                                                          *
 * Purpose : Generate and emit code for a function.                         *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *           00-10-17  Support for CRT function _alloca() added.            *
 *           02-07-10  Bugfix: stack corrupted with _alloca() + SEH.        *
 *           04-03-03  Don't emit stack frame for leaf functions.           *
 *           04-03-03  Bugfix: always emit stack frame for inline asm.      *
 *           04-06-21  Bugfix: don't handle leaf functions if no optimize!  *
 *           04-07-02  Support for fastcall functions added.                *
 *           04-07-10  Use cheaper registers in leaf functions.             *
 *           04-11-26  Call peephole optimizer from here.                   *
 *           04-12-28  Bugfix: can't use registers in functions with SEH!   *
 *                                                                          *
 ****************************************************************************/

static void I(function)(SYMBOL *f, SYMBOL *caller[], SYMBOL *callee[], int ncalls)
{
    int useargs;
    int sehsize;
    int argsize;
    int argsave;
    int i;
    uint_t safemask;
    LIST *savelist;

    /* remember instruction list, clear it for this function */
    savelist = aslist; aslist = NULL;

    usedmask[IREG] = usedmask[FREG] = 0;
    freemask[IREG] = freemask[FREG] = ~(unsigned)0;

    if (options.pragmaopt && !f->u.fcn.sehlist)
    {
        tmask[IREG] = (1<<EDI|1<<ESI|1<<EBX|1<<EDX|1<<ECX|1<<EAX);
        vmask[IREG] = (1<<EDI|1<<ESI|1<<EBX);

        /* change REGISTER to AUTO for float locals */
        no_register_floats();

        /* set REGISTER only for most promising locals */
        safe_vmask(&vmask[IREG], FALSE);
        best_function_regsyms(callee, bitcount(vmask[IREG]));

        if (ncalls == 0)
        {
            /* must get safe mask before generate_function_code() */
            safemask = (1<<EDI|1<<ESI|1<<EBX|1<<ECX|1<<EDX);
            safe_vmask(&safemask, FALSE);
        }
    }
    else
    {
        tmask[IREG] = (1<<EDI|1<<ESI|1<<EBX|1<<EDX|1<<ECX|1<<EAX);
        vmask[IREG] = 0;
    }

    /* remove possible trash from last visit */
    intreg[ECX]->x.regnode->vbl = NULL;
    intreg[EDX]->x.regnode->vbl = NULL;

    argsize = argsave = useargs = 0;
    for (i = 0; callee[i]; i++)
    {
        SYMBOL *p = callee[i];
        SYMBOL *q = caller[i];
        assert(q);

        q->type = p->type;  /* added 03-09-07 (removed hack from dag.c) */

        /* special handling of fastcall register arguments */
        if (i < NFASTARGS && isfast(f->type) && (isint(q->type) || isptr(q->type)) && p->ref != 0)
        {
            SYMBOL *rsym = argreg(i+1, q->type->size);
            if (rsym != NULL)
            {
                uint_t fastmask = (1<<ECX|1<<EDX);
                safe_vmask(&fastmask, TRUE);

                q->sclass = REGISTER;
                q->x.regnode = rsym->x.regnode;
                q->x.name = rsym->x.name;

                if (!p->addressed && ncalls == 0 && (fastmask & rsym->x.regnode->mask) != 0 && vmask[IREG] & (1<<EDI|1<<ESI))
                {
                    /* the argument can stay in place */
                    p->sclass = REGISTER;
                    p->x.regnode = rsym->x.regnode;
                    p->x.regnode->vbl = p;
                    p->x.name = rsym->x.name;
                    /* make sure the register isn't used for temps */
                    tmask[IREG] &= ~rsym->x.regnode->mask;
                    /* signal the register as being used, and not free */
                    freemask[IREG] &= ~rsym->x.regnode->mask;
                    usedmask[IREG] |= rsym->x.regnode->mask;
                    /* free another register, to help the register allocator */
                    if (vmask[IREG] & (1<<ESI))
                        vmask[IREG] &= ~(1<<ESI);
                    else if (vmask[IREG] & (1<<EDI))
                        vmask[IREG] &= ~(1<<EDI);
                }
                else
                {
                    p->sclass = REGISTER;
                    if (!register_variable(p, (*IR->x.rmap)(ttob(p->type))))
                    {
                        argsave += p->type->size;
                        p->x.offset = -argsave;
                        p->x.name = stringf("%d", p->x.offset);
                    }
                }
                continue;
            }
        }

        p->x.offset = q->x.offset = argsize + ARGOFFSET;
        p->x.name = q->x.name = stringf("%d", p->x.offset);

        if (isfloat(p->type))
            p->sclass = q->sclass = AUTO;
        else
            register_variable(p, regmap(ttob(p->type)));

        /* check usage if not fastcall argument */
        if (p->ref != 0) useargs = TRUE;

        /* size of real arguments on the stack */
        argsize += roundup(q->type->size, 4);
    }
    assert(caller[i] == 0);

    sehsize = f->u.fcn.sehlist ? 24 : 0;
    offset = maxoffset = sehsize + argsave;

    generate_function_code(caller, callee);

    /* try using cheaper registers in leaf functions (avoid callee saved registers) */
    if (options.pragmaopt && !f->u.fcn.sehlist && ncalls == 0 && !f->assembler)
    {
        if ((usedmask[IREG] & (1<<ECX)) == 0 && (safemask & (1<<ECX)) != 0)
        {
            if (usedmask[IREG] & safemask & (1<<EDI))
                reassign_register(EDI, ECX);
            else if (usedmask[IREG] & safemask & (1<<ESI))
                reassign_register(ESI, ECX);
            else if (usedmask[IREG] & safemask & (1<<EBX))
                reassign_register(EBX, ECX);
        }
        if ((usedmask[IREG] & (1<<EDX)) == 0 && (safemask & (1<<EDX)) != 0)
        {
            if (usedmask[IREG] & safemask & (1<<EDI))
                reassign_register(EDI, EDX);
            else if (usedmask[IREG] & safemask & (1<<ESI))
                reassign_register(ESI, EDX);
            else if (usedmask[IREG] & safemask & (1<<EBX))
                reassign_register(EBX, EDX);
        }
    }

    print("[function %s]\n", f->x.name);
    print("%s:\n", f->x.name);

    if (options.hookcall)
    {
        print("[extern __penter]\n");
        print("call __penter\n");
    }

    if (f->attr.naked)
    {
        if (f->hasalloca)  /* alloca() needs a stack frame */
            apperror(RCERROR(ERROR_ILLEGAL_ALLOCA_USAGE));

        if (options.dbglevel > 1) print("..?S%s:\n", f->x.name);
        emit_function_code();
        if (options.dbglevel > 1) print("..?E%s:\n", f->x.name);
    }
    else
    {
        /* Must have stack frame when calling sub-functions, use SEH, _alloca(), or inline assembler */
        /* Ugly hack: once the debugger understands FPO records we can remove 'options.dbglevel > 1' */
        bool_t needframe = (!options.pragmaopt || maxoffset || ncalls != 0 && useargs || f->u.fcn.sehlist || f->hasalloca || f->assembler || options.dbglevel > 1);
        int pushsize;

        framesize = 0;
        if (needframe)
        {
            print("push ebp\n");
            print("mov ebp,esp\n");

            if (sehsize) function_seh(f);

            framesize = roundup(maxoffset, 4) - sehsize;
            if (framesize >= 4096)
                print("mov eax,%d\ncall ___chkstk\n", framesize), rtimp[RT_CHKSTK] = 1;
            else if (framesize)
                print("sub esp,%d\n", framesize);
        }
        else  /* emit FPO record */
        {
            int oldseg = cseg;
            (*IR->segment)(FPORECS);
            print("dd %s\n", f->x.name);
            print("dd ..?X%s-%s\n", f->x.name, f->x.name);
            print("dd 0\n");
            print("dw %u\n", argsize / 4);
            print("db 0\n");
            print("db 0\n");
            (*IR->segment)(oldseg);
        }

        /* number of bytes to pop on return */
        retsize = iscdecl(f->type) ? 0 : argsize;

        pushsize = 0;  /* size of saved registers */
        if (usedmask[IREG] & (1<<EBX)) print("push ebx\n"), pushsize += 4;
        if (usedmask[IREG] & (1<<ESI)) print("push esi\n"), pushsize += 4;
        if (usedmask[IREG] & (1<<EDI)) print("push edi\n"), pushsize += 4;

        /* first argument offset for leaf functions, or zero */
        leafargs = needframe ? 0 : pushsize + 4;

        if (sehsize) print("mov [ebp + (-24)],esp\n");

        if (options.dbglevel > 1) print("..?S%s:\n", f->x.name);
        emit_function_code();
        if (options.dbglevel > 1) print("..?E%s:\n", f->x.name);

        if (f->hasalloca)
            print("lea esp,[ebp-%d]\n", sehsize + framesize + pushsize);  /* bugfix 02-07-10 */

        if (usedmask[IREG] & (1<<EDI)) print("pop edi\n");
        if (usedmask[IREG] & (1<<ESI)) print("pop esi\n");
        if (usedmask[IREG] & (1<<EBX)) print("pop ebx\n");

        if (needframe)
        {
            if (sehsize)
            {
                print("mov ecx,dword [ebp-16]\n");
                print("mov [fs:__except_list],ecx\n");
            }

            if (framesize || sehsize || f->hasalloca || f->assembler)
                print("mov esp,ebp\n");
            print("pop ebp\n");
        }

        print(retsize ? "ret %d\n" : "ret\n", retsize);
    }

    print("..?X%s:\n", f->x.name);

    align(16);

    /* optimize instructions for this function */
    if (options.pragmaopt)
        peephole_optimizer(generic_rules);

    if (options.pragmaopt == MINSPACE)
        peephole_optimizer(minspace_rules);

    if (options.maxopt)
        peephole_optimizer(ppro_rules);

    if (options.maxopt && options.pragmaopt == MAXSPEED)
        peephole_optimizer(p4_rules);

    /* append this function to the instruction list */
    if (savelist != NULL)
    {
        LIST *t = savelist->link; savelist->link = aslist->link; aslist->link = t;
    }
}

/****************************************************************************
 *                                                                          *
 * Function: no_register_floats                                             *
 *                                                                          *
 * Purpose : Keep floats out of the register allocator.                     *
 *                                                                          *
 * History : Date      Reason                                               *
 *           04-12-20  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void no_register_floats(void)
{
    CODE *cp;

    for (cp = codehead.next; cp != NULL; cp = cp->next)
    {
        if (cp->kind == CODE_BLOCKBEG)
        {
            SYMBOL **sym;

            for (sym = cp->u.block.locals; *sym != NULL; sym++)
            {
                if ((*sym)->sclass == REGISTER && isfloat((*sym)->type))
                    (*sym)->sclass = AUTO;
            }
        }
    }
}

/****************************************************************************
 *                                                                          *
 * Function: safe_vmask                                                     *
 *                                                                          *
 * Purpose : Keep "unsafe" registers out of the register allocator.         *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *           04-07-10  Check EDX register too (leaf function optimization). *
 *           04-12-12  Added fastleaf argument.                             *
 *           05-01-02  Try to be smarter about long long usage.             *
 *                                                                          *
 ****************************************************************************/

static void safe_vmask(uint_t *vmaskp, bool_t fastleaf)
{
    CODE *cp;
    NODE *p;

    for (cp = codehead.next; cp != NULL; cp = cp->next)
    {
        switch (cp->kind)
        {
            case CODE_GEN:
            case CODE_JUMP:
            case CODE_LABEL:
                for (p = cp->u.forest; p != NULL; p = p->link)
                    safe_vmask_tree(vmaskp, fastleaf, p);
                break;

            case CODE_ASM:
                *vmaskp &= ~(1<<EDI|1<<ESI|1<<EBX|1<<ECX|1<<EDX);
                break;

            default:
                break;
        }
    }
}

/****************************************************************************
 *                                                                          *
 * Function: safe_vmask_tree                                                *
 *                                                                          *
 * Purpose : Subfunction to safe_vmask() - see clobber().                   *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *           04-07-09  Support for long long's "require" vmask = 0.         *
 *           04-07-10  Check EDX register too (leaf function optimization). *
 *           04-07-15  Added operators INTRIN1{S}, INTRIN2{S}.              *
 *           04-10-30  Bugfix: ASGN+B for 4 byte struct was buggy.          *
 *           04-11-20  Added INTRIN_CPUID.                                  *
 *           04-12-09  Added INTRIN_WCSCPY.                                 *
 *           04-12-12  Added fastleaf argument - very few char registers.   *
 *           04-12-18  Bugfix: modified MULU4, DIVI4, DIVU4, MODI4, MODU4.  *
 *           05-01-04  Check for long long operations with minimum fuzz.    *
 *                                                                          *
 ****************************************************************************/

static void safe_vmask_tree(uint_t *vmaskp, bool_t fastleaf, NODE *p)
{
    int i;

    /* long long operations with minimum register fuzz */
    if (p->op == RET+I+sizeop(8) && p->kids[0]->op == INDIR+I+sizeop(8) && isaddrop(p->kids[0]->kids[0]->op) ||
        p->op == RET+U+sizeop(8) && p->kids[0]->op == INDIR+U+sizeop(8) && isaddrop(p->kids[0]->kids[0]->op) ||
        p->op == ARG+I+sizeop(8) && p->kids[0]->op == INDIR+I+sizeop(8) && isaddrop(p->kids[0]->kids[0]->op) ||
        p->op == ARG+U+sizeop(8) && p->kids[0]->op == INDIR+U+sizeop(8) && isaddrop(p->kids[0]->kids[0]->op))
        return;
    /* long long operations with assumed register fuzz */
    else if (opsize(p->op) == 8 && (optype(p->op) == I || optype(p->op) == U))
    {
        *vmaskp = 0;
        return;
    }

    /* byte addressing limited to AL, BL, CL, DL */
    if (fastleaf && opsize(p->op) == 1)
        *vmaskp &= ~(1<<ECX|1<<EDX);

    switch (p->op)
    {
        case ASGN+B:
            *vmaskp &= ~(1<<EDI|1<<ESI|1<<ECX);
            break;

        case ARG+B:
            *vmaskp &= ~(1<<EDI|1<<ESI|1<<ECX);
            break;

        case MUL+U+sizeop(4):
            *vmaskp &= ~(1<<EDX);
            break;

        case DIV+I+sizeop(4):
        case DIV+U+sizeop(4):
            *vmaskp &= ~(1<<EDX);
            if (options.pragmaopt != MAXSPEED ||
                (generic(p->kids[1]->op) != CNST && !(generic(p->kids[1]->op) == INDIR &&
                specific(p->kids[1]->kids[0]->op) == VREG+P && p->kids[1]->syms[RX]->u.t.cse &&
                generic(p->kids[1]->syms[RX]->u.t.cse->op) == CNST)))
            {
                *vmaskp &= ~(1<<ECX);
            }
            break;

        case MOD+I+sizeop(4):
        case MOD+U+sizeop(4):
            *vmaskp &= ~(1<<ECX|1<<EDX);
            break;

        case LSH+I+sizeop(4):
        case LSH+U+sizeop(4):
        case RSH+I+sizeop(4):
        case RSH+U+sizeop(4):
            if (generic(p->kids[1]->op) != CNST && !(generic(p->kids[1]->op) == INDIR &&
                specific(p->kids[1]->kids[0]->op) == VREG+P && p->kids[1]->syms[RX]->u.t.cse &&
                generic(p->kids[1]->syms[RX]->u.t.cse->op) == CNST))
            {
                *vmaskp &= ~(1<<ECX);
            }
            break;

        case CVF+I+sizeop(4):
            if (options.microsoft)
                *vmaskp &= ~(1<<EDX);
            break;

        case INTRIN1+I+sizeop(4):
        case INTRIN1+U+sizeop(4):
        case INTRIN1+P+sizeop(4):
        case INTRIN1S+I+sizeop(4):
        case INTRIN1S+U+sizeop(2):
        case INTRIN1S+U+sizeop(4):
        case INTRIN1S+P+sizeop(4):
        case INTRIN2+I+sizeop(4):
        case INTRIN2+U+sizeop(4):
        case INTRIN2+P+sizeop(4):
        case INTRIN2S+I+sizeop(4):
        case INTRIN2S+U+sizeop(2):
        case INTRIN2S+U+sizeop(4):
        case INTRIN2S+P+sizeop(4):
        case INTRIN1S+U+sizeop(8):
        case INTRIN2S+V:
            if (p->syms[0]->u.c.v.i == INTRIN_STRCPY)
                *vmaskp &= ~(1<<ECX|1<<EDX);
            else if (p->syms[0]->u.c.v.i == INTRIN_WCSCPY)
                *vmaskp &= ~(1<<ECX|1<<EDX);
            else if (p->syms[0]->u.c.v.i == INTRIN_STRCMP)
                *vmaskp &= ~(1<<ECX|1<<EDX);
            else if (p->syms[0]->u.c.v.i == INTRIN_MEMSET)
                *vmaskp &= ~(1<<ECX);
            else if (p->syms[0]->u.c.v.i == INTRIN_ABS)
                *vmaskp &= ~(1<<EDX);
            else if (p->syms[0]->u.c.v.i == INTRIN_LABS)
                *vmaskp &= ~(1<<EDX);
            else if (p->syms[0]->u.c.v.i == INTRIN_CPUID)
                *vmaskp &= ~(1<<EAX|1<<ECX|1<<EDX);
            break;
    }

    for (i = 0; i < NELEMS(p->kids) && p->kids[i]; i++)
        safe_vmask_tree(vmaskp, fastleaf, p->kids[i]);
}

/****************************************************************************
 *                                                                          *
 * Function: reassign_register                                              *
 *                                                                          *
 * Purpose : Reassign to a cheaper register in a leaf function.             *
 *                                                                          *
 * History : Date      Reason                                               *
 *           04-07-10  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void reassign_register(int src, int dst)
{
    CODE *cp;
    NODE *p;

    for (cp = codehead.next; cp != NULL; cp = cp->next)
    {
        switch (cp->kind)
        {
            case CODE_GEN:
            case CODE_JUMP:
            case CODE_LABEL:
                for (p = cp->u.forest; p != NULL; p = p->x.next)
                    reassign_register_tree(p, src, dst);
                break;

            default:
                break;
        }
    }

    assert(intreg[dst]->x.regnode->mask == shortreg[dst]->x.regnode->mask &&
           intreg[dst]->x.regnode->mask == charreg[dst]->x.regnode->mask);

    usedmask[IREG] &= ~intreg[src]->x.regnode->mask;
    usedmask[IREG] |= intreg[dst]->x.regnode->mask;
}

/****************************************************************************
 *                                                                          *
 * Function: reassign_register_tree                                         *
 *                                                                          *
 * Purpose : Subfunction to reassign_register().                            *
 *                                                                          *
 * History : Date      Reason                                               *
 *           04-07-10  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void reassign_register_tree(NODE *p, int src, int dst)
{
    if (p)
    {
        if (p->syms[RX] && p->syms[RX]->x.regnode)
        {
            if (p->syms[RX]->x.regnode == intreg[src]->x.regnode)
                p->syms[RX] = intreg[dst], p->syms[RX]->x.name = intreg[dst]->x.name;
            else if (p->syms[RX]->x.regnode == shortreg[src]->x.regnode)
                p->syms[RX] = shortreg[dst], p->syms[RX]->x.name = shortreg[dst]->x.name;
            else if (charreg[src] /* only 4 charreg's */ && p->syms[RX]->x.regnode == charreg[src]->x.regnode)
                p->syms[RX] = charreg[dst], p->syms[RX]->x.name = charreg[dst]->x.name;
        }

        reassign_register_tree(p->kids[0], src, dst);
        reassign_register_tree(p->kids[1], src, dst);
    }
}

/****************************************************************************
 *                                                                          *
 * Function: function_seh                                                   *
 *                                                                          *
 * Purpose : Initialize "Structured Exception Handling" for a function.     *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void function_seh(SYMBOL *f)
{
    LIST *lp = f->u.fcn.sehlist;
    int lab = make_label(1);

    (*IR->segment)(LIT);

    print("@%d:\n", lab);
    do
    {
        lp = lp->link;
        /**/
        {
            SEH *seh = (SEH *)lp->data;

            seh->x.evallab = make_label(3);       /* filter */
            seh->x.xcptlab = seh->x.evallab + 1;  /* handler */
            seh->x.exitlab = seh->x.evallab + 2;  /* common tail */

            print("dd %d\n", seh->previndex);
            if (seh->type == SEH_EXCEPT)
                print("dd @%d\n", seh->x.evallab);
            else
                print("dd 0\n");
            print("dd @%d\n", seh->x.xcptlab);
        }
    } while (lp != f->u.fcn.sehlist);

    (*IR->segment)(TEXT);

    print("[extern __except_handler3]\n");
    print("[extern __except_list]\n");

    print("push byte -1\n");
    print("push dword @%d\n", lab);
    print("push dword __except_handler3\n");
    print("push dword [fs:__except_list]\n");
    print("mov [fs:__except_list],esp\n");
    print("sub esp,8\n");

    usedmask[IREG] |= (1<<EDI|1<<ESI|1<<EBX);
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::defsymbol                                           *
 *                                                                          *
 * Purpose : Build the back-end's name of a symbol.                         *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *           04-07-02  Added support for fastcall mangled names.            *
 *           04-11-05  Added support for true unmangled names.              *
 *                                                                          *
 ****************************************************************************/

static void I(defsymbol)(SYMBOL *sym)
{
    if (sym->scope >= LOCAL && sym->sclass == STATIC)
        sym->x.name = stringf("@%d", make_label(1));
    else if (sym->generated)
        sym->x.name = stringf("@%s", sym->name);
    else if (sym->scope == GLOBAL || sym->sclass == EXTERN)
    {
        if (sym->type && isfunc(sym->type) && !iscdecl(sym->type) && !options.truenomangle)
        {
            int argsize = 0, i;

            if (sym->type->u.fcn.prototype)
            {
                for (i = 0; sym->type->u.fcn.prototype[i]; i++)
                    argsize += roundup(sym->type->u.fcn.prototype[i]->size, 4);
            }

            sym->x.name = stringf(sym->attr.dllimport ?
                "__imp_%c%s@%u" : "%c%s@%u", isfast(sym->type) ? '@' : '_', sym->name, argsize);
        }
        else if (sym->attr.dllimport)
            sym->x.name = stringf("__imp__%s", sym->name);
        else
            sym->x.name = stringf("_%s", sym->name);
    }
    else if (sym->scope == CONSTANTS && (isint(sym->type) || isptr(sym->type)) &&
        sym->name[0] == '0' && sym->name[1] == 'x')
        sym->x.name = stringf("0%sH", &sym->name[2]);
    else
        sym->x.name = sym->name;
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::address                                             *
 *                                                                          *
 * Purpose : Define a address relative a symbol.                            *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void I(address)(SYMBOL *q, SYMBOL *p, long n)
{
    if (p->scope == GLOBAL || p->sclass == STATIC || p->sclass == EXTERN)
        q->x.name = stringf("%s%s%D", p->x.name, n >= 0 ? "+" : "", (intmax_t)n);
    else
    {
        assert(n <= INT_MAX && n >= INT_MIN);
        q->x.offset = p->x.offset + n;
        q->x.name = stringd(q->x.offset);
    }
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::defaddress                                          *
 *                                                                          *
 * Purpose : Initialize and address constant.                               *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void I(defaddress)(SYMBOL *sym)
{
    print("dd %s\n", sym->x.name);
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::defconst                                            *
 *                                                                          *
 * Purpose : Initialize an arithmetic constant.                             *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void I(defconst)(int suffix, int size, VALUE v)
{
    if (suffix == I && size == 1)
        print("db %d\n", (uint_t)v.u);
    else if (suffix == I && size == 2)
        print("dw %d\n", (int)v.i);
    else if (suffix == I && size == 4)
        print("dd %d\n", (int)v.i);
    else if (suffix == I && size == 8)
        print("dq 0%XH\n", (intmax_t)v.i);  /* % large X for uintmax_t !! */
    else if (suffix == U && size == 1)
        print("db 0%xH\n", (uint_t)v.u);
    else if (suffix == U && size == 2)
        print("dw 0%xH\n", (uint_t)v.u);
    else if (suffix == U && size == 4)
        print("dd 0%xH\n", (uint_t)v.u);
    else if (suffix == U && size == 8)
        print("dq 0%XH\n", (uintmax_t)v.u);  /* % large X for uintmax_t !! */
    else if (suffix == P && size == 4)
        print("dd 0%xH\n", (uint_t)v.p);
    else if (suffix == F && size == 4)
    {
        float f = (float)(double)v.d;
        print("dd 0%xH\n", *(uint_t *)&f);
    }
    else if (suffix == F && size == 8)
    {
        double d = v.d;
        print("dq 0%XH\n", *(uintmax_t *)&d);
    }
    else assert(0);
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::defstring                                           *
 *                                                                          *
 * Purpose : Initialize a string constant.                                  *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void I(defstring)(int n, char *str)
{
    bool_t inquote = TRUE;
    char *s;

    print("db '");
    for (s = str; s < str + n; s++)
    {
        if (isprint((unsigned char) *s) && *s != '\'')
        {
            if (!inquote)
            {
                print(",'");
                inquote = TRUE;
            }
            print("%c", *s);
        }
        else
        {
            if (inquote)
            {
                print("'");
                inquote = FALSE;
            }
            print(",%d", *s);
        }
    }
    if (inquote) print("'");
    print("\n");
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::export                                              *
 *                                                                          *
 * Purpose : Define a public symbol.                                        *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *           03-08-27  Condition for inline functions removed.              *
 *           03-12-01  Bugfix: export CDECL functions without '_' prefix.   *
 *           04-08-03  Bugfix: first working version of nomangle option.    *
 *                                                                          *
 ****************************************************************************/

static void I(export)(SYMBOL *sym)
{
    print("[global %s]\n", sym->x.name);

    if (sym->attr.dllexport)
    {
        int oldseg = cseg;
        (*IR->segment)(DRECTVE);
        if (isfunc(sym->type))
        {
            if (iscdecl(sym->type) || options.nomangle && !isfast(sym->type))
                print("db \" -export:%s=%s \"\n", sym->name, sym->x.name);
            else
                print("db \" -export:%s \"\n", sym->x.name);
        }
        else
        {
            print("db \" -export:%s,data \"\n", sym->x.name);
        }
        (*IR->segment)(oldseg);
    }
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::import                                              *
 *                                                                          *
 * Purpose : Define an external symbol.                                     *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void I(import)(SYMBOL *sym)
{
    if (sym->ref != 0 && !sym->intrinsic)
        print("[extern %s]\n", sym->x.name);
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::global                                              *
 *                                                                          *
 * Purpose : Define a global symbol.                                        *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *           00-12-06  Define public BSS symbol with COMMON directive.      *
 *                                                                          *
 ****************************************************************************/

static void I(global)(SYMBOL *sym)
{
    if (sym->u.seg == BSS && sym->sclass != STATIC)
    {
        print("[common %s %d]\n", sym->x.name, sym->type->size);
        noresb = TRUE;  /* don't reserve space */
    }
    else
    {
        align(sym->type->align);
        print("%s:\n", sym->x.name);
        noresb = FALSE;
    }
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::local                                               *
 *                                                                          *
 * Purpose : Define a local symbol.                                         *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void I(local)(SYMBOL *sym)
{
    if (sym->intrinsic)
    {
        /*
         * The only intrinsic local variable currently
         * supported is the value from _exception_info().
         */
        sym->x.offset = -20;
        sym->x.name = stringd(-20);
        return;
    }

    if (isfloat(sym->type))
        sym->sclass = AUTO;

    if (!register_variable(sym, (*IR->x.rmap)(ttob(sym->type))))
        mkauto(sym);
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::segment                                             *
 *                                                                          *
 * Purpose : Switch logical segments.                                       *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *           01-08-20  Section .rdata added (read only).                    *
 *           03-08-01  Section .CRT$XIC and .CRT$XTC added.                 *
 *           04-03-13  Support added for code_seg, data_seg pragmas.        *
 *                                                                          *
 ****************************************************************************/

static void I(segment)(int n)
{
    if (n == cseg)
        return;

    cseg = n;

    if (cseg == TEXT && *options.codeseg)
        print("[section %s ER]\n", options.codeseg);  /* E(xecute) R(ead) */
    else if (cseg == DATA && *options.dataseg)
        print("[section %s WR]\n", options.dataseg);  /* W(rite), R(ead) */
    else if (cseg == LIT && *options.litseg)
        print("[section %s R]\n", options.litseg);    /* R(ead) */
    else if (cseg == TEXT)
        print("[section .text]\n");
    else if (cseg == DATA)
        print("[section .data]\n");
    else if (cseg == LIT)
        print("[section .rdata]\n");
    else if (cseg == BSS)
        print("[section .bss]\n");
    else if (cseg == DRECTVE)
        print("[section .drectve]\n");
    else if (cseg == FPORECS)
        print("[section .debug$F]\n");
    else if (cseg == CVSYMS)
        print("[section .debug$S]\n");
    else if (cseg == CVTYPS)
        print("[section .debug$T]\n");
    else if (cseg == INITFN)
        print("[section .CRT$XIC]\n");  /* between .CRT$XIA and .CRT$XIZ */
    else if (cseg == EXITFN)
        print("[section .CRT$XTC]\n");  /* between .CRT$XTA and .CRT$XTZ */
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::space                                               *
 *                                                                          *
 * Purpose : Define an uninitialized block.                                 *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *           00-12-06  Don't reserve space for COMMON symbols (noresb).     *
 *                                                                          *
 ****************************************************************************/

static void I(space)(int n)
{
    if (cseg != BSS)
        print("times %d db 0\n", n);
    else if (!noresb)
        print("resb %d\n", n);
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::sehbeg                                              *
 *                                                                          *
 * Purpose : Handle the initialization of a SEH block.                      *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void I(sehbeg)(int type, SEH *seh)
{
    if (type == SEH_TRY)
    {
        print("mov dword [ebp + (-4)],%d\n", seh->index);
    }
    else if (type == SEH_EXCEPT)
    {
        print("ret\n");
        print("@%d:\n", seh->x.xcptlab);
        print("mov esp,dword [ebp + (-24)]\n");
    }
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::sehend                                              *
 *                                                                          *
 * Purpose : Handle the termination of a SEH block.                         *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void I(sehend)(int type, SEH *seh)
{
    if (type == SEH_TRY)
    {
        if (seh->type == SEH_FINALLY)
        {
            print("mov dword [ebp + (-4)],%d\n", seh->previndex);
            print("call @%d\n", seh->x.xcptlab);
            print("jmp near @%d\n", seh->x.exitlab);
            print("@%d:\n", seh->x.xcptlab);
        }
        else
        {
            print("jmp near @%d\n", seh->x.exitlab);
            print("@%d:\n", seh->x.evallab);

            if (seh->sym)
            {
                print("mov eax,dword [ebp + (-20)]\n");  /* _exception_info */
                print("mov eax,dword [eax]\n");  /* EXCEPTION_RECORD* */
                print("mov eax,dword [eax]\n");  /* ExceptionCode */
                print("mov dword [ebp + (%d)],eax\n", seh->sym->x.offset);  /* _exception_code */
            }
        }
    }
    else if (type == SEH_EXCEPT)
    {
        print("@%d:\n", seh->x.exitlab);
        print("mov dword [ebp + (-4)],%d\n", seh->previndex);
    }
    else if (type == SEH_FINALLY)
    {
        print("ret\n");
        print("@%d:\n", seh->x.exitlab);
    }
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::unwind                                              *
 *                                                                          *
 * Purpose : Handle unwinding of a SEH block.                               *
 *                                                                          *
 * History : Date      Reason                                               *
 *           01-01-11  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void I(unwind)(SEH *seh)
{
    print("push byte -1\n");
    print("lea eax,[ebp-16]\n");
    print("push eax\n");
    print("call __local_unwind2\n");
    print("pop ecx\n");
    print("pop ecx\n");

    rtimp[RT_UNWIND] = 1;
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::opcall                                              *
 *                                                                          *
 * Purpose : Return non-zero if the operator calls a library routine.       *
 *                                                                          *
 * History : Date      Reason                                               *
 *           03-09-18  Created                                              *
 *           04-03-08  Added operators CEQ, CGE, CGT, CLE, CLT, CNE.        *
 *                                                                          *
 ****************************************************************************/

static int I(opcall)(int op)
{
    switch (op)
    {
        case CVF+I+sizeop(4):  // see ARM.MD
        case CVF+I+sizeop(8):
        case DIV+I+sizeop(8):
        case DIV+U+sizeop(8):
        case MOD+I+sizeop(8):
        case MOD+U+sizeop(8):
        case MUL+I+sizeop(8):
        case MUL+U+sizeop(8):
        case LSH+I+sizeop(8):  /* maybe */
        case LSH+U+sizeop(8):  /* maybe */
        case RSH+I+sizeop(8):  /* maybe */
        case RSH+U+sizeop(8):  /* maybe */
            return 1;
        default:
            return 0;
    }
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::dbgblock                                            *
 *                                                                          *
 * Purpose : Emit debug info entries for block local variables.             *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void I(dbgblock)(int brace, int lev, SYMBOL **locals)
{
    if (brace == '{' && *locals)
    {
        int oldseg = cseg;

        do
        {
            if ((*locals)->sclass == AUTO)
                emit_cv_bprel32(*locals);
            else if ((*locals)->sclass == REGISTER)
                emit_cv_register(*locals);
            else if ((*locals)->ref != 0)
                emit_cv_data32(*locals);
        } while (*++locals);

        (*IR->segment)(oldseg);
    }
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::dbgfend                                             *
 *                                                                          *
 * Purpose : Finalize the debug info output for a function.                 *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void I(dbgfend)(SYMBOL *f, int lineno)
{
    int oldseg = cseg;

    (*IR->segment)(CVSYMS);
    print("dw 2,%u\n", CODEVIEW_SYMTYPE_END);
    (*IR->segment)(oldseg);
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::dbginit                                             *
 *                                                                          *
 * Purpose : Initialize the debug info output.                              *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void I(dbginit)(char *srcfile, char *outfile)
{
    if (options.dbglevel > 1)
    {
        int oldseg = cseg;

        (*IR->segment)(CVSYMS);
        print("dd %u\n", CODEVIEW_SYMBOLS_VERSION);
        emit_cv_objname(outfile);
        emit_cv_version();

        (*IR->segment)(CVTYPS);
        print("dd %u\n", CODEVIEW_TYPES_VERSION);

        (*IR->segment)(oldseg);
    }
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::dbgline                                             *
 *                                                                          *
 * Purpose : Emit a debug info entry for the source coordinate *cp.         *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void I(dbgline)(COORDINATE *cp)
{
    print("#line %d \"%s\"\n", cp->y, cp->file);
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::dbgsym                                              *
 *                                                                          *
 * Purpose : Output a debug info entry for the symbol sym.                  *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void I(dbgsym)(SYMBOL *sym)
{
    /* stab.c in original distribution uses: if (!p->generated && !p->computed) */
    if (!sym->temporary && !sym->generated && sym->defined)
    {
        int oldseg = cseg;

        if (isfunc(sym->type))
            emit_cv_proc32(sym);
        else if (sym->scope == GLOBAL)
            emit_cv_data32(sym);
        else if (sym->sclass == AUTO)
            emit_cv_bprel32(sym);
        else if (sym->sclass == REGISTER)
            emit_cv_register(sym);
        else if (sym->ref != 0)
            emit_cv_data32(sym);

        (*IR->segment)(oldseg);
    }
}

/****************************************************************************
 *                                                                          *
 * Function: INTERFACE::dbgtype                                             *
 *                                                                          *
 * Purpose : Output a debug info entry for the type symbol sym.             *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *           01-01-03  Only emit referenced types. This seems to shut up    *
 *                     CVPACK which otherwise crashes. Not sure we fixed    *
 *                     the real problem or just moved it.                   *
 *                                                                          *
 ****************************************************************************/

static void I(dbgtype)(SYMBOL *sym)
{
    if (sym->type && sym->type->x.typeno == 0 && sym->ref != 0)
        if (isstruct(sym->type)) emit_cv_udt32(sym);
}

/****************************************************************************
 *                                                                          *
 * Function: align                                                          *
 *                                                                          *
 * Purpose : Emit an alignment directive.                                   *
 *                                                                          *
 * History : Date      Reason                                               *
 *           00-06-06  Created                                              *
 *                                                                          *
 ****************************************************************************/

static void align(int xalign)
{
    if (options.optimize == MAXSPEED && xalign > 1)
    {
        if (cseg == TEXT)
            print("[align %d]\n", xalign);
        else
            print("[alignb %d]\n", xalign);
    }
}

/****************************************************************************
 *                                                                          *
 * Function: argreg                                                         *
 *                                                                          *
 * Purpose : Decide which register to assign to this argument, if any.      *
 *                                                                          *
 * History : Date      Reason                                               *
 *           04-07-02  Created                                              *
 *                                                                          *
 ****************************************************************************/

static SYMBOL *argreg(int argno, int sz)
{
    if (argno == 1 && sz == 1) return charreg[ECX];
    if (argno == 1 && sz == 2) return shortreg[ECX];
    if (argno == 1 && sz == 4) return intreg[ECX];

    if (argno == 2 && sz == 1) return charreg[EDX];
    if (argno == 2 && sz == 2) return shortreg[EDX];
    if (argno == 2 && sz == 4) return intreg[EDX];

    return NULL;
}


INTERFACE x86IR = {
    /* size, align, outofline */
    1, 1, 0,  /* _Bool */
    1, 1, 0,  /* char */
    2, 2, 0,  /* short */
    4, 4, 0,  /* int */
    4, 4, 0,  /* long */
    8, 8, 0,  /* long long */
    4, 4, 1,  /* float */
    8, 8, 1,  /* double */
    8, 8, 1,  /* long double */
    4, 4, 0,  /* T* (ptr) */
    0, 4, 0,  /* struct; so that ARGB keeps stack aligned */
    1,        /* little_endian */
    0,        /* wants_callb */
    1,        /* wants_argb */
    1,        /* wants_optb */
    0,        /* left_to_right */
    0,        /* wants_dag */
    0,        /* unsigned_char (default=no) */
    1,        /* wants_intrinsic */
    I(address),
    blockbeg,       /* generic */
    blockend,       /* generic */
    I(defaddress),
    I(defconst),
    I(defstring),
    I(defsymbol),
    emit,           /* generic */
    I(export),
    I(function),
    gencode,        /* generic */
    I(global),
    I(import),
    I(local),
    I(progbeg),
    I(progend),
    I(segment),
    I(space),
    I(sehbeg),
    I(sehend),
    I(unwind),
    I(opcall),
    I(dbgblock),
    0,  /* dbgend */
    I(dbgfend),
    I(dbginit),
    I(dbgline),
    I(dbgsym),
    I(dbgtype),
    {
        1,  /* max_unaligned_load */
        regmap,
        blkfetch, blkstore, blkloop,
        _label,
        _rule,
        _nts,
        _kids,
        _string,
        _templates,
        _isinstruction,
        _ntname,
        emit2,
        doarg,
        target,
        clobber,
    }
};
